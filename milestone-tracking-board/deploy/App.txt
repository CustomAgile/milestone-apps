<!DOCTYPE html>
<html>
<head>
    <title>Milestone Tracking Board</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Fri Jun 09 2017 09:10:37 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri Jun 09 2017 09:10:37 GMT-0600 (MDT)";
        var CHECKSUM = 539250182300;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        console.log("_checkChecksum", container);
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.Utilities',{
    singleton: true,
    fetchPortfolioTypes: function(){
        var deferred = Ext.create('Deft.Deferred');

        var typeStore = Ext.create('Rally.data.wsapi.Store', {
            autoLoad: false,
            model: 'TypeDefinition',
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }],
            filters: [{
                property: 'Parent.Name',
                operator: '=',
                value: 'Portfolio Item'
            }, {
                property: 'Creatable',
                operator: '=',
                value: true
            }]
        });

        typeStore.load({
            scope: this,
            callback: function (records, operation, success) {
                console.log('callback', operation, success);
                if (success){
                    deferred.resolve(records);

                } else {
                    deferred.reject("Error loading Portfolio Item Types:  " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },
    fetchWsapiCount: function(model, query_filters){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: ['ObjectID'],
            filters: query_filters,
            limit: 1,
            pageSize: 1
        }).load({
            callback: function(records, operation, success){
                if (success){
                    console.log('operation');
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchScheduleStates: function(){
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        if (success){
                            var values = [];
                            for (var i=0; i < records.length ; i++){
                                values.push(records[i].get('StringValue'));
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    }
});
(function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("MilestoneTrackingApp.IterationProgressChart", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        chartComponentConfig: {
            xtype: "rallychart",
            suppressClientMetrics: true /* keeps rallychart::lookback query time from displaying in client metrics */
        }
    });
}());
(function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("MilestoneTrackingApp.IterationProgressMixin", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        _configureYAxis: function(ticks, axis) {

            var intervalY = (this.chartComponentConfig.chartConfig.yAxis[axis].max - 0) / (ticks - 1);
            var ticksY = [];
            for (var i = 0; i < ticks; i++) {
                ticksY.push(i * intervalY);
            }
            this.chartComponentConfig.chartConfig.yAxis[axis].tickPositions = ticksY;
        },

        _configureYAxisIntervals: function () {
            var ticks = 5; // not much chart space, limit to 5
            this._configureYAxis(ticks, 0);
            if(this.chartType === "burndown") { // cumulative flow only has y axis 0
                this._configureYAxis(ticks, 1);
            }
        },

        _getElementValue: function (element) {
            if (element.textContent !== undefined) {
                return element.textContent;
            }
            return element.text;
        },

        _getStringValues: function (elements) {
            var i;
            var strings = [];
            for (i = 0; i < elements.length; i++) {
                strings.push(this._getElementValue(elements[i]));
            }
            return strings;
        },

        _getNumberValues: function (elements) {
            var i;
            var numbers = [];
            for (i = 0; i < elements.length; i++) {
                if(this._getElementValue(elements[i])) {
                    numbers.push(this._getElementValue(elements[i]).split(' ')[0] * 1);
                } else {
                    numbers.push(0);
                }

            }
            return numbers;
        },

        _computeMaxYAxisValue: function(series) {
            var i, j, max = 0.0;
            // sum each day's values and find the largest sum
            for(i=0; i < series[0].data.length; i++) {
                var val = 0.0;
                for(j=0; j < series.length; j++) {
                    // if is for insurance, _should_ always be true
                    if(series[j].data.length === series[0].data.length) {
                        val += series[j].data[i];
                    }
                }
                if(val > max) {
                    max = val;
                }
            }
            max = Math.ceil(max / 4) * 4;  // round up to multiple of 4 so we will create 5 integral tick marks

            return (max === 0) ? 4 : max;
        },

        _createChartDatafromXML: function (xml) {
            var parseXml;

            if (typeof window.DOMParser !== "undefined") {
                parseXml = function (xmlStr) {
                    return ( new window.DOMParser() ).parseFromString(xmlStr, "text/xml");
                };
            } else if (typeof window.ActiveXObject !== "undefined" &&
                new window.ActiveXObject("Microsoft.XMLDOM")) {
                parseXml = function (xmlStr) {
                    var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = "false";
                    xmlDoc.loadXML(xmlStr);
                    return xmlDoc;
                };
            } else {
                throw new Error("No XML parser found");
            }

            return parseXml(xml);
        }
    });
}());
(function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("MilestoneTrackingApp.PieChart", {
        alias: "widget.statsbannerpiechart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: {
            recordable: 'Rally.clientmetrics.ClientMetricsRecordable'
        },

        currentScope: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Pie',
        config: {
            context: null
        },

        initComponent: function() {
            this.callParent(arguments);

            if (this._storyStates === undefined) {
                Rally.data.ModelFactory.getModels({
                    types: ['UserStory'],
                    context: this.getContext(),
                    scope: this,
                    requester: this,
                    success: function(models){
                        models.UserStory.getField('ScheduleState').getAllowedValueStore().load({
                            callback: this._createStateMap,
                            requester: this,
                            scope: this
                        });
                    }
                });
            } else {
                this._loadArtifacts();
            }
        },

        _createStateMap: function(allowedValues) {
            var stateMap = ['Defined', 'In-Progress', 'Completed'],
                stateMapIndex = 0,
                storyStates = {};

            _.each(allowedValues, function(value) {
                var state = value.data.StringValue;
                if (state) {
                    if (state === stateMap[stateMapIndex + 1]) {
                        stateMapIndex++;
                    }
                    storyStates[state] = stateMap[stateMapIndex];
                }
            });

            this._storyStates = storyStates;
            this._loadArtifacts();
        },

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];

            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['PortfolioItem/Feature'],
                fetch: ['UserStories', 'PreliminaryEstimate', 'Value', 'FormattedID', 'State[Ordinal;Name]', 'LeafStoryCount', 'Name',
                    'PlannedEndDate', 'PlannedStartDate', 'ActualStartDate', 'ActualEndDate', 'PercentDoneByStoryPlanEstimate', 'PercentDoneByStoryCount'],
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this,
                autoLoad: true,
                listeners: {
                    load: this._loadChildCollections,
                    scope: this
                }
            });
        },

        _loadChildCollections: function() {
            var records = this.store.getRange();
            var promises = [];
            _.each(records, function(record) {
                if (record.get('UserStories') && record.get('UserStories').Count) {
                    var store = Ext.create('Rally.data.wsapi.Store', {
                        model: 'UserStory',
                        fetch: ['FormattedID', 'Name', 'ScheduleState', 'Blocked', 'BlockedReason', 'Feature'],
                        filters: [{
                            property: 'Feature',
                            value: record.get('_ref')
                        }, {
                            property: 'DirectChildrenCount',
                            value: 0
                        }]
                    });
                    promises.push(store.load({
                        requester: this,
                        callback: function(stories) {
                            record.get('UserStories').Results = stories;
                        }
                    }));
                }
            });

            if (promises.length > 0) {
                Deft.Promise.all(promises).then({
                    success: this._onAllDataLoaded,
                    scope: this
                });
            } else {
                this._onAllDataLoaded();
            }
        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var stories = record.get('UserStories');
                var relatedCount = record.get('LeafStoryCount');
                var planEstimate = (record.get('PreliminaryEstimate') && record.get('PreliminaryEstimate').Value) || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No stories.';

                //console.log(record.get('Name'), relatedCount, planEstimate, pointSizeForChildren);
                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (stories && stories.Results) {
                        _.each(stories.Results, function(story) {
                            this._addPointForChildItem(story, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }
                }

            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type:'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: height,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type:'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: height,
                            innerSize: 0.8 * height,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    subtitle: {
                        useHTML:true, //class refactor
                        text: '<table align="center" class="pie-chart-legend"><tr><td><span class="legend-swatch defined-sample-swatch"></span><span>Defined</td>' +
                        '<td><span class="legend-swatch in-progress-sample-swatch"></span>In-Progress</td>'+
                        '<td><span class="legend-swatch completed-sample-swatch"></span>Completed</td>'+
                        '<td><span class="legend-swatch blocked-sample-swatch"></span>Blocked</td></tr></table>',
                        verticalAlign: 'bottom',
                        floating: true,
                        x: -50,
                        y: -25
                    },
                    tooltip: {
                        formatter: this._formatTooltip
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            shadow: false,
                            center: ['50%', '50%'],
                            point: {
                                events: {
                                    click: function(event) {
                                        if (this.ref) {
                                            Rally.nav.Manager.showDetail(this.ref);
                                        }
                                    }
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = false;
            var pointSize = (record.get('PreliminaryEstimate') && record.get('PreliminaryEstimate').Value) || 1;
            var color = '#C0C0C0';
            var colorObject;

            colorObject = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(record.data, 'PercentDoneByStoryCount');
            color = colorObject.hex;

            //console.log(record.get('Name'), pointSize, record.get('PreliminaryEstimate') && record.get('PreliminaryEstimate').Value);
            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: (record.get('State') && record.get('State').Name) || '--No Entry--',
                blocked: blocked,
                schedule: colorObject.label,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _colorFromStatus: function(state, blocked) { //refactor into css and classes, should get cleaner
            var progressColors = {
                'Defined': '#C0C0C0', // light gray
                'In-Progress': '#00A9E0', // cyan
                'Completed': '#8DC63F', // lime
                'Blocked': '#EE1C25' // red
            };
            var color =  progressColors[state];
            if (blocked) {
                color = progressColors.Blocked;
            }
            return color;
        },

        _addPointForChildItem: function(record, parentFormattedID, pointSize, parentState, isParentBlocked) {
            var blocked = record.get('Blocked');
            var state = record.get('ScheduleState');
            var color = this._colorFromStatus(this._storyStates[parentState || state], blocked || isParentBlocked);

            this._childChartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: state,
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: false,
                relatedCount: 0,
                ref: record.get('_ref'),
                parentFormattedID: parentFormattedID
            });
        },

        _formatTooltip: function() {
            var relatedCount = '';
            var blockedMessage = '';
            var artifactName = this.point.rallyName ? '<b>' + this.point.name + '</b>: ' + this.point.rallyName + '<br/>' : this.point.name;

            if (this.point.blocked) {
                blockedMessage = '<b>Blocked</b>';
                if (this.point.blockedReason) {
                    blockedMessage += ': ' + this.point.blockedReason;
                }
            }

            if (this.point.schedule) {
                blockedMessage = '<b>Schedule</b>: ' + this.point.schedule;
            }

            if (this.point.series && this.point.series.name === 'Parents') {
                if(!this.point.userStory) {
                    var numRelated = this.point.relatedCount || 0;
                    relatedCount = 'Stories: ' + numRelated;
                }
                return artifactName + this.point.status + '<br/>' + relatedCount + '<br/>' + blockedMessage;
            } else {
                return artifactName + this.point.status + '<br/>' + blockedMessage;
            }
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * A ComboBox for choosing a milestone
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         items: [{
     *             xtype: 'rallymilestonecombobox'
     *          }],
     *          renderTo: Ext.getBody().dom
     *     });
     */
    Ext.define('Rally.ui.combobox.MilestoneComboBox', {
        extend: 'Rally.ui.combobox.ComboBox',
        alias: 'widget.rallymilestonecombobox',
        requires: [
            'Rally.util.DateTime',
            'Rally.data.util.Sorter'
        ],

        mixins: [
            'Rally.ui.MilestoneListHeadings'
        ],

        config: {
            allowNoEntry: false,
            hideLabel: true,
            width: 300,
            storeConfig: {
                autoLoad: true,
                model: Ext.identityFn('milestone'),
                remoteFilter: false,
                remoteSort: false,
                limit: Infinity
            },
            listConfig: {
                minWidth: 385,
                cls: 'milestone-list',
                emptyText: 'No Milestones Defined'
            },
            tpl: Ext.create('Ext.XTemplate',
                '<tpl for=".">',
                '<div class="' + Ext.baseCSSPrefix + 'boundlist-item">' +
                '<div class="milestone-name"><b>{[values.FormattedID]}</b>:  {[values._refObjectName]}</div>',
                '<div class="milestone-date">{[Rally.util.DateTime.formatWithDefault(values.TargetDate)]}</div>',
                '<div class="milestone-raw-date">{[values.TargetDate]}</div>',
                '</div>',
                '</tpl>'
            )
        },

        initComponent: function () {
            this.storeConfig.sorters = [{
                sorterFn: Rally.data.util.Sorter.getDefaultSortFn('Milestone')
            }];

            this.callParent(arguments);
        },

        createPicker: function() {
            var picker = this.callParent(arguments);

            picker.on({
                show: this._addListHeaders,
                refresh: this._addListHeaders,
                scope: this,
                filterSelectedNodes: false
            });

            return picker;
        }
    });
})();
Ext.define('MilestoneTrackingApp.CFDCalculator', {
    extend: 'Rally.data.lookback.calculator.TimeSeriesCalculator',
    config: {
        stateFieldName: 'ScheduleState',
        stateFieldValues: ['Defined', 'In-Progress', 'Completed', 'Accepted']
    },

    constructor: function(config) {
        this.initConfig(config);
        this.callParent(arguments);
    },
    runCalculation: function (snapshots) {
        var calculatorConfig = this._prepareCalculatorConfig(),
            seriesConfig = this._buildSeriesConfig(calculatorConfig);

        var calculator = this.prepareCalculator(calculatorConfig);
        calculator.addSnapshots(snapshots, this._getStartDate(snapshots), this._getEndDate(snapshots));

        return this._transformLumenizeDataToHighchartsSeries(calculator, seriesConfig);
    },
    getMetrics: function() {
        return _.map(this.getStateFieldValues(), function(stateFieldValue) {
            return  {
                as: stateFieldValue,
                groupByField: this.getStateFieldName(),
                allowedValues: [stateFieldValue],
                f: 'groupByCount',
                display: 'area'
            };
        }, this);
    }
});
(function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("MilestoneTrackingApp.CumulativeFlowChart", {
        alias: "widget.statsbannercumulativeflowchart",
        extend: "Ext.Container",
        requires: [ 'Rally.ui.chart.Chart' ],
        mixins: [
            "MilestoneTrackingApp.IterationProgressMixin",
            "MilestoneTrackingApp.IterationProgressChart"
        ],
        cls: 'rally-iteration-progress-cumulative-flow-chart',
        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Cumulative Flow',
        minimalMode: false,
        initComponent: function() {
            this.callParent(arguments);

            var chartConfig = {
                storeType: 'Rally.data.lookback.SnapshotStore',
                storeConfig: this._getStoreConfig(),
                calculatorType: 'MilestoneTrackingApp.CFDCalculator',
                calculatorConfig: {
                    stateFieldName: 'ScheduleState',
                    stateFieldValues: this.scheduleStates
                }
            };
            chartConfig = this.minimalMode ? this._createMinimalConfig(chartConfig) : this._createChartConfig(chartConfig);
            this.add(chartConfig);

        },
        _getStoreConfig: function(){
            var oids = [];

            Ext.Array.each(this.store.getRange(), function(r){
                var children = r.get('DirectChildrenCount') || 0;
                if (children === 0 || r.get('_type') === 'defect'){
                    oids.push(r.get("ObjectID"));
                }
            });

            return {
                find: {
                    ObjectID: {$in: oids}
                },
                fetch: ['ScheduleState'],
                hydrate: ['ScheduleState'],
                sort: {
                    _ValidFrom: 1
                },
                context: this.context.getDataContext(),
                limit: Infinity
            };
        },
        _createMinimalConfig: function(overrides){
            var config = this._createChartConfig(overrides);
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;

            return Ext.Object.merge(config, {
                chartConfig: {
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },
                    yAxis: [{
                        title: {
                            text: null
                        },
                        min: 0,
                        labels: { enabled: false }
                    }],
                    title: { text: null }
                }
            });
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;


            return Ext.Object.merge({
                xtype: 'rallychart',
                //updateAfterRender: Ext.bind(this._onLoad, this),

                chartColors: [  // RGB values obtained from here: http://ux-blog.rallydev.com/?cat=23
                    "#C0C0C0",  // $grey4
                    "#FF8200",  // $orange
                    "#F6A900",  // $gold
                    "#FAD200",  // $yellow
                    "#CADDA3",  // $lime
                    "#1E7C00"
                ],
                chartConfig: {
                    chart: {

                        //zoomType: 'xy',
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        alignTicks: false,
                        animation: true,
                        type: "area",
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        area: {
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            stacking: 'normal'
                        }
                    },
                    legend: {
                        enabled: true
                    },
                    title: {text: null},
                    xAxis: {
                        tickmarkPlacement: 'on',
                        labels: {
                            formatter: function(){
                                return Rally.util.DateTime.format(new Date(this.value), 'MMM-dd');
                            },
                            rotation: 75
                        },
                        tickPositioner: function () {
                            var positions = [],
                                tick = Math.floor(this.dataMin),
                                increment = Math.ceil((this.dataMax - this.dataMin) / 10);

                            if (this.dataMax !== null && this.dataMin !== null) {
                                for (tick; tick - increment <= this.dataMax; tick += increment) {
                                    positions.push(tick);
                                }
                            }
                            return positions;
                        }
                    },
                    yAxis: [{
                        title: {text: null},
                        min: 0,
                        labels: {
                            style: {color: "#005eb8"}
                        }
                    }]
                }
            }, overrides || {});
        }
    });

})();
(function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("MilestoneTrackingApp.MinimalPieChart", {
        alias: "widget.statsbannerminimalpiechart",
        extend: "MilestoneTrackingApp.PieChart",

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];
            this._createDataPointsFromSummary();
        },

        _createDataPointsFromSummary: function() {
            _.each(this.store.getRange(), function(record){
                var summary = record.get('Summary');
                var totalChildItems = record.get('LeafStoryCount');
                var planEstimate = (record.get('PreliminaryEstimate') && record.get('PreliminaryEstimate').Value) || 1;
                var nullPointString = 'No stories.';
                var keys, state, scheduleState, blocked, count;

                var pointSizeForChildren = (planEstimate / totalChildItems) || 1;

                this._addPointForTopLevelItem(record, totalChildItems);

                if (totalChildItems === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                }
                if (summary.UserStories && summary.UserStories.Count){
                    keys = _.keys(summary.UserStories['schedulestate+blocked']);
                    _.each(keys, function(key) {
                        state = key.split('+');
                        scheduleState =  state[0];
                        blocked = state[1] === 'true';
                        count = summary.UserStories['schedulestate+blocked'][key];
                        _.each(_.range(0, count), function(point) {
                            this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, scheduleState, blocked);
                        }, this);
                    }, this);
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var stories = record.get('UserStories');
                var relatedCount = record.get('LeafStoryCount');
                var planEstimate = (record.get('PreliminaryEstimate') && record.get('PreliminaryEstimate')) || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No stories.';

                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (stories && stories.Results) {
                        _.each(stories.Results, function(story) {
                            this._addPointForChildItem(story, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type:'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: height,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type:'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: height,
                            innerSize: 0.8 * height,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            shadow: false,
                            center: ['50%', '50%'],
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = false;
            var pointSize = (record.get('PreliminaryEstimate') && record.get('PreliminaryEstimate').Value) || 1;
            var color = '#C0C0C0';
            var colorObject;

            colorObject = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(record.data, 'PercentDoneByStoryCount');
            color = colorObject.hex;

            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: record.get('State') && record.get('State').Name,
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _addPointForChildItem: function(parentFormattedID, pointSize, state, blocked) {
            var color = this._colorFromStatus(this._storyStates[state], blocked);

            this._childChartData.push({
                y: pointSize,
                color: color,
                status: state,
                blocked: blocked,
                hasChildren: false,
                relatedCount: 0,
                parentFormattedID: parentFormattedID
            });
        }
    });
})();
/**
 * This needs to be overridden for the _getLeafCount function to workaround what I think is a bug in the API.
 */
var origGetPrototypeBody = Ext.data.NodeInterface.getPrototypeBody;

Ext.override(Rally.ui.grid.data.NodeInterface, {
    extend: 'Ext.data.NodeInterface',

    statics: Ext.apply(Ext.data.NodeInterface.prototype.self, {

        /**
         * @private
         * @property
         */
        noLayoutFields: /^(expanded|loaded|loading|leaf|leafCount)$/,

        getPrototypeBody: function() {
            var protoBody = origGetPrototypeBody(),
                originalDestroy = protoBody.destroy,
                originalReplaceChild = protoBody.replaceChild,
                originalOnChildNodesAvailable = protoBody.onChildNodesAvailable;

            return Ext.apply(protoBody, {
                save: function (options) {
                    options = options || {};
                    options.params = options.params || {};
                    options.params.fetch = options.params.fetch || true;

                    var store = this.store && this.store.treeStore || this.store;
                    if (store && _.isFunction(store.getParentFetch) && _.isFunction(store.getChildFetch)) {
                        var fetchOptions = {
                            node: this,
                            fetch: options.params.fetch
                        };
                        options.params.fetch = this.getDepth() === 1 ?
                            store.getParentFetch(fetchOptions) : store.getChildFetch(fetchOptions);
                    }

                    return this.self.superclass.save.apply(this, [options]);
                },

                set: function (name, value) {
                    var isInTree = Rally.ui.grid.data.NodeInterface.noLayoutFields.test(name) &&  this.store && this.store.ownerTree,
                        tree = this.store && this.store.ownerTree,
                        ret;

                    if (isInTree) {
                        tree.suspendLayouts();
                    }

                    ret = this.callParent(arguments);

                    if (isInTree) {
                        tree.resumeLayouts();
                    }

                    return ret;
                },

                destroy: function(silent) {
                    if (this.parentNode) {
                        this.parentNode.decrementLeafCount();
                    }
                    this._removeChildren();

                    return originalDestroy.apply(this, [silent]);
                },

                replaceChild: function(newChild, oldChild) {
                    oldChild.replacedByNode = newChild;
                    return originalReplaceChild.apply(this, [newChild, oldChild]);
                },

                onChildNodesAvailable: function(records, recursive, callback, scope) {
                    if (!this._isVisible()) {
                        // childNodes came back after expand,
                        // but user has scrolled and this node (the parent) has moved out of the view.
                        // cancel expand
                        var view = this._getView();
                        if (view) {
                            view.fireEvent('afternonvisibleitemexpand', this);
                            return;
                        }
                    }

                    return originalOnChildNodesAvailable.apply(this, arguments);
                },

                updateCollectionCount: function(collectionName, count) {
                    var collection = this.get(collectionName);

                    if (collection) {
                        collection.Count = count;
                    }

                    this.set('dirtyCollection', true);
                },

                incrementLeafCount: function() {
                    this.set('leafCount', (this.get('leafCount') || 0) + 1);
                    this.set('leaf', false);
                },

                decrementLeafCount: function() {
                    this.set('leafCount', (this.get('leafCount') || 1) - 1);

                    if (this.get('leafCount') > 1) {
                        this.set('leaf', true);
                    }
                },

                resetLeafCount: function(enableHierarchy, expandedCollectionNames) {
                    if (enableHierarchy) {
                        var leafCount = this._getLeafCount(expandedCollectionNames);
                        this.set('leaf', leafCount < 1);
                        this.set('leafCount', leafCount);
                    } else {
                        this.set('leaf', true);
                        this.set('leafCount', 0);
                    }
                },

                _isVisible: function() {
                    var store = this.store;

                    if (store && _.isFunction(store.isRootNode)) {
                        return store.isRootNode(this) || this._getViewNode();
                    }

                    return true;
                },

                _getView: function() {
                    var grid = this.store && this.store.ownerTree;

                    return grid && grid.getView();
                },

                _getViewNode: function() {
                    var view = this._getView();

                    return view && view.getNode(this);
                },

                _getLeafCount: function(expandedCollectionNames) {
                    var typePath = this.get('_type').toLowerCase(),
                        collectionNames = Ext.Array.from(expandedCollectionNames[typePath] || []);

                    var count =  _.reduce(collectionNames, function(accumulator, collectionName) {
                        var collectionVal = this.get(collectionName);
                        if (collectionVal && collectionVal.Count) {
                            accumulator += collectionVal.Count;
                        }

                        return accumulator;
                    }, 0, this);

                    if (count === 0 && this.get('DirectChildrenCount') > 0){
                        return this.get('DirectChildrenCount');
                    }
                    return count;
                },

                _removeChildren: function() {
                    this.suspendEvents(false);
                    _.each(_.clone(this.childNodes), function(node) {
                        node.parentNode.decrementLeafCount();
                        node.parentNode.removeChild(node, false);
                    });
                    this.resumeEvents();
                }
            });
        }
    })
});
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows user to see stats for a timebox in a horizontal bar format
     */
    Ext.define('MilestoneTrackingApp.StatsBanner', {
        extend: 'Ext.container.Container',
        alias:'widget.statsbanner',
        mixins: [
            'Rally.Messageable',
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],
        cls: 'stats-banner',
        layout: 'hbox',
        border: 0,
        width: '100%',
        stateful: true,
        stateEvents: ['expand', 'collapse'],
        filters: [],
        firstPortfolioItemName: 'Feature',

        config: {
            context: null,
            expanded: true,

        },

        items: [
            {
                xtype: 'statsbanneraccepted',
                byCount: false,
                title: 'Accepted Points',
                unitLabel: "Points",
                flex: 2,
                tooltip: "The summed Plan Estimates of user stories and defects explicitly associated with the Milestone and defects associated with a User Story that is explicitly associated with the Milestone that are in the Accepted (or higher) ScheduleState."
            },{
                xtype: 'statsbannerestimatedstories',
                title: "Estimated Work Items",
                unitLabel: "Work Items",
                flex: 2,
                tooltip: "The number of user stories and defects explicitly associated with the Milestone or defects associated with a User Story that is explicitly associated with the Milestone that have a plan estimate of 0 or higher."
            },{
                xtype: 'statsbanneraccepted',
                byCount: true,
                title: 'Accepted Count',
                unitLabel: "work items",
                flex: 2,
                tooltip: "The number of user stories and defects explicitly associated with the Milestone and defects associated with a User Story that is explicitly associated with the Milestone that are in the Accepted (or higher) ScheduleState."
            },{
                xtype: 'statsbannerdefects',
                title: 'Active Defects',
                unitLabel: ' Defects',
                flex: 2,
                tooltip: "The number of defects explicitly associated with the Milestone or associated with a User Story that is explicitly associated with the Milestone that are not in a Closed State."
            },{
                xtype: 'statsbannertestcases',
                title: 'Test Cases Passed',
                unitLabel: 'executed',
                flex: 2,
                tooltip: "The number of test cases associated with a User Story or Defect associated with the milestone.  Passed Test cases are the number of those test cases where the Last Verdict = Passed.  Executed test cases are the number of those test cases that have been run, but where the Last Verdict is not Passed."
            },{
                xtype: 'statsbannerdefectdensity',
                title: 'Defect Density',
                unitLabel: 'Defects/Test Cases',
                flex: 2,
                tooltip: "Defect Density =( (Total Number of Defects – Cancelled defects – Rejected Defects) / Total Number of Test Cases Executed)"
            },{
                xtype: 'statsbannermilestoneprogress',
                flex: 2
            },{xtype: 'statsbannercollapseexpand', flex: 0}
        ],

        constructor: function(config) {
            this.callParent(arguments);
        },

        initComponent: function() {
            this.addEvents(
                /**
                 * @event
                 * Fires when expand is clicked
                 */
                'expand',
                /**
                 * @event
                 * Fires when collapse is clicked
                 */
                'collapse'
            );

            this.subscribe(this, Rally.Message.objectDestroy, this._update, this);
            this.subscribe(this, Rally.Message.objectCreate, this._update, this);
            this.subscribe(this, Rally.Message.objectUpdate, this._update, this);
            this.subscribe(this, Rally.Message.bulkUpdate, this._update, this);

            var filters = this._getBannerFilters();

            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['HierarchicalRequirement','Defect'],
                fetch: ['ObjectID', 'FormattedID', 'ScheduleState', 'PlanEstimate','Iteration','Name','StartDate','EndDate','State','DirectChildrenCount'],
                filters: filters,
                context: this.context.getDataContext(),
                limit: Infinity
            });

            //need to configure the items at the instance level, not the class level (i.e. don't use the 'defaults' config)
            this.items = this._configureItems(this.items);

            this.on('expand', this._onExpand, this);
            this.on('collapse', this._onCollapse, this);
            this.store.on('load', this._checkForLateStories, this);
            this.callParent(arguments);
            this._update();

        },
        _checkForLateStories: function(store){
            var lateStories = [],
                targetDate = Rally.util.DateTime.fromIsoString(this.timeboxRecord.get(this.timeboxEndDateField));

            _.each(this.store.getRange(), function(record){
                var iteration = record.get('Iteration'),
                    children = record.get('DirectChildrenCount') || 0;
                if (children === 0){
                    if (iteration){
                        if (Rally.util.DateTime.fromIsoString(iteration.EndDate) > targetDate){
                            lateStories.push(record);
                        }
                    } else {
                        lateStories.push(record);
                    }
                }

            }, this);
            if (lateStories.length > 0){
                this.fireEvent('latestoriesfound', lateStories);
            }
        },
        onRender: function() {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this._setExpandedOnChildItems();
            this.callParent(arguments);
        },

        applyState: function (state) {
            if (Ext.isDefined(state.expanded)) {
                this.setExpanded(state.expanded);
            }
            this._setExpandedOnChildItems();
        },

        getState: function(){
            return {
                expanded: this.expanded
            };
        },

        _setExpandedOnChildItems: function() {
            _.each(this.items.getRange(), function(item) {
                item.setExpanded(this.expanded);
            }, this);
        },

        _getItemDefaults: function() {
            return {
                flex: 1,
                context: this.context,
                store: this.store,
                listeners: {
                    ready: this._onReady,
                    scope: this
                }
            };
        },

        _onReady: function() {
            this._readyCount = (this._readyCount || 0) + 1;
            if(this._readyCount === this.items.getCount()) {
                this.recordComponentReady();
                delete this._readyCount;
            }
        },

        _onCollapse: function() {
            this.addCls('collapsed');
            this.setExpanded(false);

            _.invoke(this.items.getRange(), 'collapse');
        },

        _onExpand: function() {
            this.removeCls('collapsed');
            this.setExpanded(true);

            _.invoke(this.items.getRange(), 'expand');
        },

        _hasTimebox: function() {
            return true;
        },

        _configureItems: function(items) {
            var defaults = {
                flex: 1,
                context: this.context,
                store: this.store,
                timeboxRecord: this.timeboxRecord,
                timeboxEndDateField: this.timeboxEndDateField,
                scheduleStates: this.scheduleStates,
                closedDefectStates: this.closedDefectStates,
                cancelledDefectStates: this.cancelledDefectStates,
                listeners: {
                    ready: this._onReady,
                    scope: this
                }
            };

            return _.map(items, function(item) {
                return _.defaults(_.cloneDeep(item), defaults);
            });
        },

        _update: function () {
            if(this._hasTimebox()) {
                this.store.load();
            }
        },
        _getBannerFilters: function(){
            var filters = Ext.create('Rally.data.wsapi.Filter',{
                property: 'Milestones',
                value: this.timeboxRecord.get('_ref')
            });
            filters = filters.or({
                property: 'Requirement.Milestones',
                value: this.timeboxRecord.get('_ref')
            });

            if (this.includeFeatureUserStories){
                filters = filters.or({
                    property: this.featureName + ".Milestones",
                    value: this.timeboxRecord.get('_ref')
                });
            }

            return filters;
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Abstract class to handle expanding / collapsing for banner widgets
     */
    Ext.define('MilestoneTrackingApp.BannerWidget', {
        extend: 'Ext.Component',
        alias: 'widget.bannerwidget',

        config: {
            expanded: true
        },

        cls: 'stat-panel',

        data: {},

        tpl: [
            '<div class="expanded-widget"></div>',
            '<div class="collapsed-widget"></div>'
        ],

        onRender: function() {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this.callParent(arguments);
        },

        expand: function() {
            this.removeCls('collapsed');
            this.setExpanded(true);
        },

        collapse: function() {
            this.addCls('collapsed');
            this.setExpanded(false);
        }
    });
})();

(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * gauge chart for stats banner
     * abstract class
     */
    Ext.define('MilestoneTrackingApp.Gauge', {
        extend: 'MilestoneTrackingApp.BannerWidget',
        alias:'widget.statsbannergauge',

        requires: [
            'Rally.ui.chart.Chart',
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],

        config: {
            context: null,
            store: null
        },

        onDataChanged: Ext.emptyFn,
        getChartEl: Ext.emptyFn,
        _getChartConfig: Ext.emptyFn,

        _tzOffsetPromises: {},

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        expand: function() {
            this.callParent();
            if (this.chart) {
                this.chart.doLayout();
            } else {
                this._addChart(this._getChartConfig({}));
            }
        },

        onRender: function() {
            this.callParent(arguments);
            if (!this._getTimebox()) {
                this._addEmptyChart();
            }
        },
        _getTimebox: function(){
            if (this.getContext().getTimeboxScope() && this.getContext().getTimeboxScope().getRecord()){
                return this.getContext().getTimeboxScope().getRecord();
            }
            return null;
        },
        _addEmptyChart: function() {
            this._cleanupChart();
            this._addChart({
                chartData: {
                    series: [{
                        data: [
                            {
                                name: '',
                                y: 100,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            });
        },

        _cleanupChart: function () {
            if (this.chart) {
                this.chart.destroy();
                delete this.chart;
            }
        },

        onDestroy: function () {
            this._cleanupChart();
            this.callParent(arguments);
        },

        onResize: function() {
            if (this.chart && !this.getEl().up('.stats-banner.collapsed')) {
                this.chart.updateLayout();
            }
            this.callParent(arguments);
        },

        refreshChart: function(chartConfig) {
            Ext.suspendLayouts();
            this._cleanupChart();
            if (this.rendered && this.expanded) {
                this._addChart(chartConfig);
            }
            Ext.resumeLayouts();
            this.fireEvent('ready', this);
        },

        _addChart: function(chartConfig) {
            var height = 62;
            this.chart = Ext.create('Rally.ui.chart.Chart', Ext.apply({
                loadMask: false,
                renderTo: this.getChartEl(),
                cls: 'gauge',
                chartConfig: {
                    chart: {
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        defaultSeriesType: 'pie',
                        height: height,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0
                    },
                    plotOptions: {
                        pie: {
                            borderWidth: 0,
                            center: ['50%', '50%'],
                            dataLabels: {
                                enabled: false
                            },
                            size: height - 4,
                            innerSize: height - 14,
                            enableMouseTracking: false, //turns off chart hover, but for tooltips you'll need this on
                            shadow: false
                        }
                    },
                    title: '',
                    tooltip: {
                        enabled: false
                    }
                }
            }, chartConfig));
        },

        getTimeboxData: function() {
            return this._getTZOffset().then({
                success: function (tzOffset) {
                    var timebox = this._getTimebox();
                    if(timebox) {
                        return Rally.util.Timebox.getCounts(
                            timebox.get('ReleaseStartDate'),
                            timebox.get('ReleaseDate'),
                            this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays,
                            tzOffset);
                    } else {
                        return {
                            remaining: 0,
                            workdays: 0
                        };
                    }
                },
                scope: this
            });
        },

        _getTZOffset: function() {
            var projectRef = Rally.util.Ref.getRelativeUri(this.getContext().getProject());
            if (!Ext.isDefined(this._tzOffsetPromises[projectRef])) {
                var deferred = this._tzOffsetPromises[projectRef] = Ext.create('Deft.Deferred');
                Rally.environment.getIoProvider().httpGet({
                    url: Rally.environment.getServer().getWsapiUrl() + '/iteration',
                    params: {
                        includeSchema: true,
                        pagesize:1,
                        fetch: false,
                        project: projectRef
                    },
                    success: function(results) {
                        deferred.resolve((results.Schema.properties.EndDate.format.tzOffset || 0) / 60);
                    },
                    requester: this,
                    scope: this
                });
            }
            return this._tzOffsetPromises[projectRef];
        },

        getAcceptanceData: function () {
            var acceptanceData = {
                accepted: 0,
                total: 0,
                acceptedCount: 0,
                count: 0
            };

            _.each(this.store.getRange(), function (rec) {
                acceptanceData.accepted += rec.get('AcceptedLeafStoryPlanEstimateTotal');
                acceptanceData.total += rec.get('LeafStoryPlanEstimateTotal');
                acceptanceData.acceptedCount += rec.get('AcceptedLeafStoryCount');
                acceptanceData.count += rec.get('LeafStoryCount');
            });

            return Deft.Promise.when(acceptanceData);
        },

        getEstimatedData: function () {
            var acceptanceData = {
                accepted: 0,
                total: 0
            };

            _.each(this.store.getRange(), function (rec) {
                acceptanceData.accepted += rec.get('LeafStoryCount') - rec.get('UnEstimatedLeafStoryCount');
                acceptanceData.total += rec.get('LeafStoryCount');
            });

            return Deft.Promise.when(acceptanceData);
        },

        _getScheduleStates: function () {
            if (this._scheduleStates) {
                return Deft.Promise.when(this._scheduleStates);
            } else {
                return this.store.model.getField('ScheduleState').getAllowedValueStore().load().then({
                    success: function (records) {
                        this._scheduleStates = _.map(records, function (record) {
                            return record.get('StringValue');
                        });
                        return this._scheduleStates;
                    },
                    scope: this,
                    requester: this
                });
            }
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * gauge chart for stats banner
     * abstract class
     */
    Ext.define('MilestoneTrackingApp.ConfigurableGauge', {
        extend: 'MilestoneTrackingApp.BannerWidget',
        alias:'widget.statsbannerconfigurablegauge',

        requires: [
            'Rally.ui.chart.Chart',
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],


        tpl: [
            '<div class="expanded-widget">',
                '<div class="stat-title"  data-qtip="{tooltip}">{title}&nbsp;<span class="icon-help"></span></div>',
                '<div class="stat-metric">',
                    '<div class="metric-chart"></div>',
                    '<div class="metric-chart-text percent-offset">',
                        '{percentage}<div class="metric-percent">%</div>',
                    '</div>',
                    '<div class="metric-subtext">{calculatedUnits} of {totalUnits} {unit}<tpl if="secondaryUnit">, {secondaryCalculatedUnits} of {secondaryTotalUnits} {secondaryUnit}</tpl></div>',
                '</div>',
            '</div>',
            '<div class="collapsed-widget">',
                '<div class="stat-title">{title}</div>',
                '<div class="stat-metric">{percentage}<span class="metric-percent">%</span></div>',
            '</div>'
        ],

        config: {
            calculatedUnitFilter: null,
            totalUnitFilter: null,
            data: {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: 0,
                unit: '',
                title: ''
            }
        },

        _tzOffsetPromises: {},

        getTooltip: function(values){
            if (values.tooltip){
                return values.tooltip;
            }
            return '';
        },
        initComponent: function() {
            Ext.QuickTips.init();
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },
        onDataChanged: function() {
            var data = this._getRenderData();
            this.update(data);
            this.refreshChart(this._getChartConfig(data));
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        //Override this function in the parent.
        _getRenderData: function() {
            return {};
        },

        _getChartConfig: function(renderData) {
               var data = [{
                        name: '',
                        y: 100,
                        color: Rally.util.Colors.grey1
               }];

                if (!Ext.isEmpty(renderData)){
                    if (renderData.chartData && renderData.chartData instanceof Array){
                        data = renderData.chartData;
                     } else {
                        var percentage = renderData.percentage,
                            percentagePlanned = percentage % 100 || 100,
                            color = Rally.util.Colors.cyan_med,
                            secondaryColor = Rally.util.Colors.grey1;

                        if (percentage > 100) {
                            color = Rally.util.Colors.blue;
                            secondaryColor = Rally.util.Colors.cyan;
                        } else if (percentage > 70) {
                            color = Rally.util.Colors.cyan;
                        } else if (percentage === 0) {
                            color = Rally.util.Colors.grey1;
                        }

                        data = [
                            {
                                name: renderData.title + ' Total',
                                y: percentagePlanned,
                                color: color
                            },
                            {
                                name: '',
                                y: 100 - percentagePlanned,
                                color: secondaryColor
                            }
                        ]
                    }
                }

            return {
                chartData: {
                    series: [{
                        data: data
                    }]
                }
            };
        },
        expand: function() {
            this.callParent();
            if (this.chart) {
                this.chart.doLayout();
            } else {
                this._addChart(this._getChartConfig({}));
            }
        },

        onRender: function() {
            this.callParent(arguments);
            if (this.store.getRange().length === 0) {
                this._addEmptyChart();
            }
        },
        _addEmptyChart: function() {
            this._cleanupChart();
            this._addChart({
                chartData: {
                    series: [{
                        data: [
                            {
                                name: '',
                                y: 100,
                                color: Rally.util.Colors.grey1,
                                pct: "N/A"
                            }
                        ]
                    }]
                }
            });
        },

        _cleanupChart: function () {
            if (this.chart) {
                this.chart.destroy();
                delete this.chart;
            }
        },

        onDestroy: function () {
            this._cleanupChart();
            this.callParent(arguments);
        },

        onResize: function() {
            if (this.chart && !this.getEl().up('.stats-banner.collapsed')) {
                this.chart.updateLayout();
            }
            this.callParent(arguments);
        },

        refreshChart: function(chartConfig) {
            Ext.suspendLayouts();
            this._cleanupChart();
            if (this.rendered && this.expanded) {
                this._addChart(chartConfig);
            }
            Ext.resumeLayouts();
            this.fireEvent('ready', this);
        },

        _addChart: function(chartConfig) {
            var height = 70;
            this.chart = Ext.create('Rally.ui.chart.Chart', Ext.apply({
                loadMask: false,
                renderTo: this.getChartEl(),
                cls: 'gauge',
                chartConfig: {
                    chart: {
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        defaultSeriesType: 'pie',
                        height: height,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0
                    },
                    plotOptions: {
                        pie: {
                            borderWidth: 0,
                            center: ['55%', '20%'],
                            dataLabels: {
                                enabled: false
                            },
                            size: height * .70,
                            innerSize: height * .60,
                            enableMouseTracking: false, //turns off chart hover, but for tooltips you'll need this on
                            shadow: false
                        }
                    },
                    title: '',
                    tooltip: {
                        enabled: false
                    }
                }
            }, chartConfig));
        },



        _getTZOffset: function() {
            var projectRef = Rally.util.Ref.getRelativeUri(this.getContext().getProject());
            if (!Ext.isDefined(this._tzOffsetPromises[projectRef])) {
                var deferred = this._tzOffsetPromises[projectRef] = Ext.create('Deft.Deferred');
                Rally.environment.getIoProvider().httpGet({
                    url: Rally.environment.getServer().getWsapiUrl() + '/iteration',
                    params: {
                        includeSchema: true,
                        pagesize:1,
                        fetch: false,
                        project: projectRef
                    },
                    success: function(results) {
                        deferred.resolve((results.Schema.properties.EndDate.format.tzOffset || 0) / 60);
                    },
                    requester: this,
                    scope: this
                });
            }
            return this._tzOffsetPromises[projectRef];
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('MilestoneTrackingApp.Accepted', {
        extend: 'MilestoneTrackingApp.ConfigurableGauge',
        alias:'widget.statsbanneraccepted',

        config: {
            data: {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: 0,
                title: "Accepted Points",
                byCount: false
            }
        },

        _getRenderData: function() {

            var total = 0,
                accepted_total = 0
                byCount = this.byCount,
                acceptedScheduleStates = this.scheduleStates.slice(this.scheduleStates.indexOf('Accepted'));

            Ext.Array.each(this.store.getRange(), function(r) {
                var children = r.get('DirectChildrenCount') || 0;
                if (children === 0){
                    if (!byCount) {
                        total += r.get('PlanEstimate') || 0;
                        if (Ext.Array.contains(acceptedScheduleStates, r.get('ScheduleState'))){
                            accepted_total += r.get('PlanEstimate') || 0;
                        }
                    } else {
                        total++;
                        if (Ext.Array.contains(acceptedScheduleStates, r.get('ScheduleState'))){
                            accepted_total ++;
                        }
                    }
                }

            });

            var pct = total === 0 ? 0 : Math.round(accepted_total / total * 100);

            var data = {
                percentage: pct,
                calculatedUnits: accepted_total,
                totalUnits: total,
                unit: this.unitLabel,
                title: this.title,
                tooltip: this.tooltip || ''
            };
            return data;

        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('MilestoneTrackingApp.Defects', {
        extend: 'MilestoneTrackingApp.ConfigurableGauge',
        alias:'widget.statsbannerdefects',

        config: {
            data: {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: 0,
                title: 'Active Defects'
            }
        },

        _getRenderData: function() {

            var total = 0,
                active = 0,
                closedStates = this.closedDefectStates;

            Ext.Array.each(this.store.getRange(), function(r) {
                if (r.get('_type').toLowerCase() === 'defect'){
                    if (!Ext.Array.contains(closedStates, r.get('State'))){
                        active++;
                    }
                    total++;
                }

            });

            var pct = total === 0 ? 0 : Math.round(active / total * 100);

            var data = {
                percentage: pct,
                calculatedUnits: active,
                totalUnits: total,
                unit: this.unitLabel,
                title: this.title,
                tooltip: this.tooltip
            };
            return data;

        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('MilestoneTrackingApp.DefectDensity', {
        extend: 'MilestoneTrackingApp.ConfigurableGauge',
        alias:'widget.statsbannerdefectdensity',

        config: {
            data: {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: 0,
                title: 'Defect Density'
            }
        },
        initComponent: function() {

            var filters = Ext.create('Rally.data.wsapi.Filter',{
                property: 'WorkProduct.Milestones',
                value: this.timeboxRecord.get('_ref')
            },{
                property: "LastVerdict",
                operator: "!=",
                value: ""
            });

            this.testCaseStore = Ext.create('Rally.data.wsapi.Store',{
                model: 'TestCase',
                fetch: ['ObjectID'],
                filters: filters,
                pageSize: 1,
                limit: 1
            });

            this.mon(this.testCaseStore, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);

            this.testCaseStore.load();
        },

    _getRenderData: function() {

            var total = 0,
                cancelled = 0,
                cancelledStates = this.cancelledDefectStates;

            var executedTestCases = this.testCaseStore.getTotalCount() || 0;

            Ext.Array.each(this.store.getRange(), function(r) {
                if (r.get('_type').toLowerCase() === 'defect'){
                    if (Ext.Array.contains(cancelledStates, r.get('State'))){
                        cancelled++;
                    }
                    total++;
                }
            });

//        Defect Density =( (Total Number of Defects – Cancelled defects – Rejected Defects) / Total Number of Test Cases Executed))
            var pct = executedTestCases > 0 ? (total - cancelled)/executedTestCases * 100 : 0;
            var data = {
                percentage: Math.round(pct),
                calculatedUnits: (total - cancelled),
                totalUnits: executedTestCases,
                unit: this.unitLabel,
                title: this.title,
                tooltip: this.tooltip
            };
            return data;

        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('MilestoneTrackingApp.TestCases', {
        extend: 'MilestoneTrackingApp.ConfigurableGauge',
        alias:'widget.statsbannertestcases',

        config: {
            data: {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: 0,
                title: 'Test Status'
            }
        },

        initComponent: function() {

            var filters = Ext.create('Rally.data.wsapi.Filter',{
                property: 'WorkProduct.Milestones',
                value: this.timeboxRecord.get('_ref')
            });

            this.store = Ext.create('Rally.data.wsapi.Store',{
                model: 'TestCase',
                fetch: ['LastRun','LastVerdict'],
                filters: filters
            });

            this.callParent(arguments);
            this.store.load();
        },
        _getRenderData: function() {
            var total = 0,
                passed = 0,
                executed = 0;

            Ext.Array.each(this.store.getRange(), function(r) {
                if (r.get('LastRun')){
                    executed++;
                    if (r.get('LastVerdict') === "Pass"){
                        passed++;
                    }
                }
                total++;
            });


            var data = [{
                    name: 'Total',
                    y: total - executed,
                    color: Rally.util.Colors.grey1
                },{
                    name: 'Executed',
                    y: executed - passed,
                    color: "#FAD200"
                },{
                    name: 'Passed',
                    y: passed,
                    color: '#8DC63F'
                }];

            var pct = total === 0 ? 0 : Math.round(passed / total * 100);
            var data = {
                chartData: data,
                title: this.title,
                unit: this.unitLabel,
                calculatedUnits: executed,
                totalUnits: total,
                percentage: pct,
                secondaryCalculatedUnits: passed,
                secondaryTotalUnits: executed,
                secondaryUnit: "passed",
                tooltip: this.tooltip
            };
            return data;

        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows collapse/expand toggle for stats banner
     */
    Ext.define('MilestoneTrackingApp.CollapseExpand', {
        extend: 'MilestoneTrackingApp.BannerWidget',
        alias:'widget.statsbannercollapseexpand',
        requires: [],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="toggle-icon icon-chevron-up"></div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="toggle-icon icon-chevron-down"></div>',
            '</div>'
        ],

        componentCls: 'collapse-expand',

        bubbleEvents: ['collapse', 'expand'],

        afterRender: function() {
            this.callParent(arguments);
            this.getEl().on('click', this._onCollapseExpandClick, this);
            this.fireEvent('ready', this);
        },

        _onCollapseExpandClick: function() {
            if (this.expanded) {
                this.fireEvent('collapse', this);
            } else {
                this.fireEvent('expand', this);
            }
        },

        expand: function() {
            this.callParent(arguments);
            this.doComponentLayout();
        },

        collapse: function() {
            this.callParent(arguments);
            this.doComponentLayout();
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('MilestoneTrackingApp.EstimatedStories', {
        extend: 'MilestoneTrackingApp.ConfigurableGauge',
        alias:'widget.statsbannerestimatedstories',
        config: {
            calculatedUnitFilter: null,
            totalUnitFilter: null,
            data: {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: 0,
                byCount: false
            }
        },

        _getRenderData: function() {

            var total = 0,
                estimated = 0;

            Ext.Array.each(this.store.getRange(), function(r) {
                var children = r.get('DirectChildrenCount') || 0;
                if (children === 0) {
                    total++;
                    if (r.get('PlanEstimate') && r.get('PlanEstimate') > 0) {
                        estimated++;
                    }
                }
            });

            var pct = total === 0 ? 0 : Math.round(estimated / total * 100);

            var data = {
                percentage: pct,
                calculatedUnits: estimated,
                totalUnits: total,
                unit: this.unitLabel,
                title: this.title,
                tooltip: this.tooltip
            };
            return data;

        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('MilestoneTrackingApp.popover.LateStories', {
        alias: 'widget.latestoriespopover',
        extend: 'Rally.ui.popover.Popover',

        constructor: function (config) {
            config.items = [
                {
                    xtype: 'rallygrid',
                    model: 'User Story',
                    headerCls: 'leftright-header-text',
                    columnCfgs: ['FormattedID', 'Name', 'Feature', 'PlanEstimate', 'Iteration', 'Release', 'Project', 'Owner'],
                    pagingToolbarCfg: {
                        pageSizes: [5, 10, 15]
                    },
                    store: config.store
                }
            ];

            this.callParent(arguments);
        }
    });
    /**
     * shows defects active for timebox
     */
    Ext.define('MilestoneTrackingApp.LateStories', {
        extend: 'MilestoneTrackingApp.BannerWidget',
        alias:'widget.statsbannerlatestories',
        requires: [],

        config: {
            context: null,
            store: null,
            data: {
                activeCount: 0
            }
        },

        tpl: [
            '<div class="expanded-widget">',
            '<span style="cursor: pointer">',
            '<div class="stat-title">Late Stories</div>',
            '<div class="stat-metric">',
            '<div class="metric-icon icon-story"></div>{activeCount}',
            '<div class="stat-secondary">Late</div>',
            '</span>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-story"></span>',
            '<div class="stat-title">Late Stories</div>',
            '<div class="stat-metric">{activeCount}</div>',
            '</div>'
        ],

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.on('render', function () {
                this.getEl().on('click', function () {
                    this._onClickLateStories();
                }, this);
            }, this);
            this.callParent(arguments);
        },

        onDataChanged: function() {
            this.update(this._getRenderData());
            this.fireEvent('ready', this);
        },

        _getLateStoriesCount: function() {
            var lateStories = 0,
                targetDate = Rally.util.DateTime.fromIsoString(this.timeboxRecord.get(this.timeboxEndDateField));

            _.each(this.store.getRange(), function(record){
                var iteration = record.get('Iteration'),
                    children = record.get('DirectChildrenCount') || 0;
                if (children === 0){
                    if (iteration){
                         if (Rally.util.DateTime.fromIsoString(iteration.EndDate) > targetDate){
                            lateStories++;
                        }
                    } else {
                        lateStories++;
                    }
                }

            }, this);
            return lateStories;
        },

        _getRenderData: function() {
            return {activeCount: this._getLateStoriesCount()};
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows days remaining for timebox
     */
    Ext.define('MilestoneTrackingApp.TimeboxEnd', {
        extend: 'MilestoneTrackingApp.ConfigurableGauge',
        alias:'widget.statsbannertimeboxend',

        config: {
            timeboxRecord: null,
            timeboxEndDateField: null,
            data: {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: 0,
                unitLabel: 'days',
                title: 'Milestone End'
            }
        },

        _getRenderData: function() {

            var end_date = this.timeboxRecord.get(this.timeboxEndDateField),
                today = new Date();

            var total = Rally.util.DateTime.getDifference(end_date, today, 'day');

            var data = {
                percentage: 0,
                calculatedUnits: 0,
                totalUnits: total,
                unit: this.unitLabel,
                title: this.title
            };
            return data;
        }
        //requires: [
        //    'Rally.util.Timebox',
        //    'Rally.util.Colors'
        //],
        //
        //tpl: [
        //    '<div class="expanded-widget">',
        //    '<div class="stat-title">{type} End</div>',
        //    '<div class="stat-metric">',
        //    '<div class="metric-chart"></div>',
        //    '<div class="metric-chart-text">',
        //    '{remaining}',
        //    '</div>',
        //    '<div class="metric-subtext">days left of {workdays}</div>',
        //    '</div>',
        //    '</div>',
        //    '<div class="collapsed-widget">',
        //    '<div class="stat-title">{type} End</div>',
        //    '<div class="stat-metric">{remaining}<span class="stat-metric-secondary"> days</span></div>',
        //    '</div>'
        //],
        //
        //config: {
        //    data: {
        //        type: 'Release',
        //        remaining: 0,
        //        workdays: 0
        //    }
        //},
        //
        //onDataChanged: function() {
        //    Deft.Promise.all([
        //        this.getAcceptanceData(),
        //        this.getTimeboxData()
        //    ]).then({
        //        success: this._onDataAssembled,
        //        scope: this
        //    });
        //},
        //
        //getChartEl: function() {
        //    return this.getEl().down('.metric-chart');
        //},
        //
        //_getRenderData: function() {
        //    var data = _.merge(
        //        {type: Ext.String.capitalize(this.getContext().getTimeboxScope().getType())},
        //        this.acceptanceData,
        //        this.timeboxData
        //    );
        //
        //    return data;
        //},
        //
        //_onDataAssembled: function (results) {
        //    this.acceptanceData = results[0];
        //    this.timeboxData = results[1];
        //
        //    var renderData = this._getRenderData();
        //    this.update(renderData);
        //
        //    this.refreshChart(this._getChartConfig(renderData));
        //},
        //
        //_getChartConfig: function (renderData) {
        //    var decimal = renderData.remaining / renderData.workdays,
        //        percentLeft = decimal < 1 ? Math.round(decimal * 100) : 0,
        //        color = Rally.util.Colors.cyan;
        //
        //    if (renderData.total === 0) {
        //        color = Rally.util.Colors.grey1;
        //    } else if (percentLeft === 0) {
        //        color = renderData.accepted === renderData.total ? Rally.util.Colors.lime : Rally.util.Colors.blue;
        //    } else if (percentLeft <= 25) {
        //        color = Rally.util.Colors.blue;
        //    }
        //
        //    return {
        //        chartData: {
        //            series: [{
        //                data: [
        //                    {
        //                        name: 'Days Done',
        //                        y: 100 - percentLeft,
        //                        color: color
        //                    },
        //                    {
        //                        name: 'Days Left',
        //                        y: percentLeft,
        //                        color: Rally.util.Colors.grey1
        //                    }
        //                ]
        //            }]
        //        }
        //    };
        //}
    });
})();
(function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('MilestoneTrackingApp.IterationProgressDialogChartToggle', {
        requires:['Rally.ui.Button'],
        extend:'Ext.Container',
        alias:'widget.iterationprogressdialogcharttoggle',

        componentCls: 'iteration-progress-toggle-button-group',
        layout: 'hbox',
        border: 1,
        width: 106,
        activeButtonCls: 'active',

        defaultType: 'rallybutton',

        config: {
            startingIndex: 0
        },

        items: [{
            cls: 'toggle left pie-chart',
            iconCls: 'icon-pie',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            style: {
                fontSize: '15px'
            },
            toolTipConfig: {
                html: 'Pie',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked pie chart'
        },
            {
                cls: 'toggle center burndown',
                iconCls: 'icon-bars',
                frame: false,
                toggleGroup: 'iterationprogressviewtoggle',
                toolTipConfig: {
                    html: 'Burndown',
                    anchor: 'top',
                    hideDelay: 0
                },
                userAction:'IterationProgressApp - User clicked burndown'
            },
            {
                cls: 'toggle right cumulativeflow',
                iconCls: 'icon-graph',
                frame: false,
                toggleGroup: 'iterationprogressviewtoggle',
                toolTipConfig: {
                    html: 'Cumulative Flow',
                    anchor: 'top',
                    hideDelay: 0
                },
                userAction:'IterationProgressApp - User clicked CFD'
            }],

        initComponent: function(config) {
            this.initConfig(config);
            this.callParent(arguments);

            this.addEvents([
            /**
             * @event toggle
             * Fires when the toggle value is changed.
             * @param {String} toggleState 'burndown' or 'cumulativeflow' or 'pie'.
             */
                'toggle'
            ]);

            this.items.each(function(item) {
                item.on('click', this._onButtonClick, this);
            }, this);

            this.setCurrentItem(this.startingIndex);
        },

        _onButtonClick: function(btn) {
            var btnIndex = this.items.indexOf(btn);
            if (btnIndex !== this._activeIndex) {
                this._setActive(btn);
                this.fireEvent('toggle', this, btnIndex);
            }
        },

        _setActive: function(btn) {
            this.items.each(function(item, btnIndex) {
                if (item === btn) {
                    if (!item.hasCls(this.activeButtonCls.split(' ')[0])) {
                        item.addCls(this.activeButtonCls);
                        this._activeIndex = btnIndex;
                    }
                } else {
                    item.removeCls(this.activeButtonCls);
                }
            }, this);
        },

        setCurrentItem: function(itemIndex) {
            this._setActive(this.items.get(itemIndex));
        }
    });
})();

(function(){

    var Ext = window.Ext4 || window.Ext;

    /**
     * shows burndown for timebox
     */
    Ext.define('MilestoneTrackingApp.IterationProgressDialog', {
        extend: 'Rally.ui.dialog.Dialog',
        alias:'widget.statsbanneriterationprogressdialog',

        config: {
            startingIndex: 0,
            autoShow: true,
            draggable: true,
            disableScroll: true,
            width: 820,
            height: 650,
            closable: true,
            store: null,
            context: null
        },
        layout: {
            type: 'vbox',
            align: 'center'
        },
        cls: 'iteration-progress-dialog',

        constructor: function (config){
            this.initConfig(config || {});
            this.callParent(arguments);
        },

        initComponent: function(){
            var chartWidth = 704;
            var chartHeight = this.height * .90;

            this.callParent(arguments);

            this.chart = this.add({
                xtype: 'statsbannercumulativeflowchart',
                width: chartWidth,
                height: chartHeight,
                store: this.store,
                timeboxRecord: this.timeboxRecord,
                scheduleStates: this.scheduleStates,
                context: this.context
            });
            this.title = this.chart.displayTitle;

        },


        _afterLayout: function(){
            Ext.defer(this._setChart, 10, this, [this.startingIndex]);
        },

        _setChart: function(chartIndex) {
            //this.carousel.setCurrentItem(chartIndex);
            //this.toggle.setCurrentItem(chartIndex);
            // need to bypass the setTitle method as it causes a relayout of the page messing up the carousel
            this.header.titleCmp.textEl.update(this.chart.displayTitle);
        },

        //_onCarouselMove: function(carousel){
        //    this._setChart(carousel.getCurrentItemIndex());
        //}
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows burndown for timebox
     */
    Ext.define('MilestoneTrackingApp.MilestoneProgress', {
        extend: 'MilestoneTrackingApp.BannerWidget',
        alias:'widget.statsbannermilestoneprogress',

        config: {
            context: null,
            store: null
        },

        currentChartDisplayed: 0,

        stateId: 'stats-banner-iteration-progress',
        stateful: true,

        clientMetrics: {
            method: '_onChartClick',
            description: 'opened IterationProgressDialog'
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title"></div>',
            '<div class="stat-metric">',
            '<div class="stat-carousel"></div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-pie"></span>',
            '<div class="stat-title"></div>',
            '</div>'
        ],

        constructor: function(config) {
            this.stateId = Rally.environment.getContext().getScopedStateId(this.stateId);
            this.callParent(arguments);
        },

        initComponent: function(){
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);

        },

        expand: function() {
            this.callParent();
            this.onDataChanged();
        },

        _onChartClick: function() {
            //var currentIndex = this.carousel.getCurrentItemIndex();
            Ext.create('MilestoneTrackingApp.IterationProgressDialog', {
               // startingIndex: currentIndex,
                store: this.store,
                context: this.context,
                timeboxRecord: this.timeboxRecord,
                scheduleStates: this.scheduleStates,
                height: 400
            });
        },

        onDestroy: function () {
            this.callParent(arguments);
        },

        onRender: function() {
            this.callParent(arguments);
            if (this._getTimebox()) {
                this._addPlaceholder();
            }
        },
        _getTimebox: function(){
            return this.timeboxRecord || null;
        },

        onDataChanged: function() {

            if(this.rendered) {
                if (this._getTimebox()) {
                    this.update();

                    this.createCarousel();
                } else {
                    this._addPlaceholder();
                }
            }
        },

        createCarousel: function() {
            var boundClickHandler = Ext.bind(this._onChartClick, this);

            if (this.chart){
                this.chart.destroy();
            }

            this.chart = Ext.create('MilestoneTrackingApp.CumulativeFlowChart',{
                width: 150,
                height: 60,
                minimalMode: true,
                itemId: 'cumulative-flow-chart',
                timeboxRecord: this.timeboxRecord,
                clickHandler: boundClickHandler,
                minimalMode: true,
                scheduleStates: this.scheduleStates,
                context: this.context,
                renderTo: this.getEl().down('.stat-carousel'),
                store: this.store
            });
            this._updateTitle('Cumulative Flow');
        },

        _updateTitle: function(title){
            _.each(this.getEl().query('.stat-title'), function(el){
                Ext.fly(el).update(title);
            }, this);
        },

        _addPlaceholder: function() {
            this.update();

            if (this.expanded) {
                this.chart = Ext.create('Ext.Container', {
                    renderTo: this.getEl().down('.stat-carousel'),
                    html: 'no iteration data'
                });
            }
        }
    });
})();
(function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("MilestoneTrackingApp.BurndownChart", {
        alias: "widget.statsbannerburndownchart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: [
            "MilestoneTrackingApp.IterationProgressMixin",
            "MilestoneTrackingApp.IterationProgressChart"
        ],

        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Burndown',
        minimalMode: false,
        onChartDataLoaded: Ext.emptyFn,

        initComponent: function() {
            this.callParent(arguments);

            Ext.Ajax.request({
                url: '/slm/charts/itsc.sp',
                params: {
                    iterationOid: this.context.getTimeboxScope().getRecord().getId(),
                    cpoid: this.context.getProject().ObjectID
                },
                method: 'GET',
                withCredentials: true,
                success: function(response, request) {
                    this._loadData(response.responseText);
                },
                requester: this,
                scope: this
            });
        },

        _loadData: function(chartData) {
            var xmlDoc = this._createChartDatafromXML(chartData);
            this._createBurndownChartDatafromXML(xmlDoc);
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;

            return Ext.Object.merge({
                xtype: 'rallychart',
                chartColors: ["#005eb8", "#666666", "#8dc63f" ],
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartConfig: {
                    chart: {
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        zoomType: 'xy',
                        alignTicks: false,
                        animation: true,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            shadow: false,
                            borderWidth: 0,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            },
                            events: {
                                click: clickChartHandler
                            }
                        },
                        column: {
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            }
                        }
                    },
                    legend: { enabled: true },
                    title: { text: null },
                    xAxis: {
                        tickmarkPlacement: 'on',
                        tickInterval: 1
                    },
                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { style: { color: "#005eb8" } }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { style: { color: "#8dc63f" } }
                        }
                    ]
                },
                chartData: {
                    categories: [],
                    series: [
                        {
                            name: "To Do",
                            type: "column",
                            data: [],
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Ideal",
                            type: "line",
                            dashStyle: "Solid",
                            data: [],
                            marker : {
                                enabled : true,
                                radius : 3
                            },
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Accepted",
                            type: "column",
                            data: [],
                            yAxis: 1,
                            tooltip: { enabled: false }
                        }
                    ]
                }
            }, overrides || {});
        },

        _createMinimalConfig: function(){
            var config = this._createChartConfig();
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;
            delete config.chartData.series[1].marker;

            config = Ext.Object.merge(config, {
                chartConfig: {
                    chart: {
                        zoomType: ''
                    },
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },

                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { enabled: false }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { enabled: false }
                        }
                    ],
                    title: { text: null }
                }
            });
            return config;
        },

        _createBurndownChartDatafromXML: function (xmlDoc) {

            this.chartComponentConfig = this.minimalMode ? this._createMinimalConfig() : this._createChartConfig();

            var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];
            var xmlChartValueText = xmlDoc.getElementsByTagName("chart_value_text")[0];
            var draw = xmlDoc.getElementsByTagName("draw")[0];
            var axis_value = xmlDoc.getElementsByTagName("axis_value")[1];

            var rows = xmlChartData.getElementsByTagName("row");

            // this makes no sense...The thing labeled Accepted in the <chart_data> element, isn't.
            // The thing that is Accepted, is buried in the <chart_value_text> element

            this.chartComponentConfig.chartData.categories = this._getStringValues(rows[0].getElementsByTagName("string")); // categories
            this.chartComponentConfig.chartData.series[0].data = this._getNumberValues(rows[1].getElementsByTagName("number")); //todo;
            this.chartComponentConfig.chartData.series[1].data = this._getNumberValues(rows[3].getElementsByTagName("number")); //ideal;
            this.chartComponentConfig.chartData.series[2].data = this._getNumberValues(xmlChartValueText.getElementsByTagName("row")[2].getElementsByTagName("number")); //accepted;
            this.chartComponentConfig.chartConfig.yAxis[0].max = axis_value.getAttribute("max") * 1;

            var texts = draw.getElementsByTagName("text");
            // find the last <text element with orientation="vertical_down" attribute, that's the max y-axis 2 setting
            for (i = 0; i < texts.length; i++) {
                if (texts[i].getAttribute("orientation") === "vertical_down") {
                    this.chartComponentConfig.chartConfig.yAxis[1].max = (this._getElementValue(texts[i]) * 1);
                }
            }
            this._configureYAxisIntervals();

            this.chartComponentConfig.chartConfig.xAxis.tickInterval = Math.floor(this.chartComponentConfig.chartData.series[0].data.length / 4);

            this.add(this.chartComponentConfig);
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        }
    });
})();
(function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("MilestoneTrackingApp.CumulativeFlowChart", {
        alias: "widget.statsbannercumulativeflowchart",
        extend: "Ext.Container",
        requires: [ 'Rally.ui.chart.Chart' ],
        mixins: [
            "MilestoneTrackingApp.IterationProgressMixin",
            "MilestoneTrackingApp.IterationProgressChart"
        ],
        cls: 'rally-iteration-progress-cumulative-flow-chart',
        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Cumulative Flow',
        minimalMode: false,
        initComponent: function() {
            this.callParent(arguments);

            var chartConfig = {
                storeType: 'Rally.data.lookback.SnapshotStore',
                storeConfig: this._getStoreConfig(),
                calculatorType: 'MilestoneTrackingApp.CFDCalculator',
                calculatorConfig: {
                    stateFieldName: 'ScheduleState',
                    stateFieldValues: this.scheduleStates
                }
            };
            chartConfig = this.minimalMode ? this._createMinimalConfig(chartConfig) : this._createChartConfig(chartConfig);
            this.add(chartConfig);

        },
        _getStoreConfig: function(){
            var oids = [];

            Ext.Array.each(this.store.getRange(), function(r){
                var children = r.get('DirectChildrenCount') || 0;
                if (children === 0 || r.get('_type') === 'defect'){
                    oids.push(r.get("ObjectID"));
                }
            });

            return {
                find: {
                    ObjectID: {$in: oids}
                },
                fetch: ['ScheduleState'],
                hydrate: ['ScheduleState'],
                sort: {
                    _ValidFrom: 1
                },
                context: this.context.getDataContext(),
                limit: Infinity
            };
        },
        _createMinimalConfig: function(overrides){
            var config = this._createChartConfig(overrides);
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;

            return Ext.Object.merge(config, {
                chartConfig: {
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },
                    yAxis: [{
                        title: {
                            text: null
                        },
                        min: 0,
                        labels: { enabled: false }
                    }],
                    title: { text: null }
                }
            });
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;


            return Ext.Object.merge({
                xtype: 'rallychart',
                //updateAfterRender: Ext.bind(this._onLoad, this),

                chartColors: [  // RGB values obtained from here: http://ux-blog.rallydev.com/?cat=23
                    "#C0C0C0",  // $grey4
                    "#FF8200",  // $orange
                    "#F6A900",  // $gold
                    "#FAD200",  // $yellow
                    "#CADDA3",  // $lime
                    "#1E7C00"
                ],
                chartConfig: {
                    chart: {

                        //zoomType: 'xy',
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        alignTicks: false,
                        animation: true,
                        type: "area",
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        area: {
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            stacking: 'normal'
                        }
                    },
                    legend: {
                        enabled: true
                    },
                    title: {text: null},
                    xAxis: {
                        tickmarkPlacement: 'on',
                        labels: {
                            formatter: function(){
                                return Rally.util.DateTime.format(new Date(this.value), 'MMM-dd');
                            },
                            rotation: 75
                        },
                        tickPositioner: function () {
                            var positions = [],
                                tick = Math.floor(this.dataMin),
                                increment = Math.ceil((this.dataMax - this.dataMin) / 10);

                            if (this.dataMax !== null && this.dataMin !== null) {
                                for (tick; tick - increment <= this.dataMax; tick += increment) {
                                    positions.push(tick);
                                }
                            }
                            return positions;
                        }
                    },
                    yAxis: [{
                        title: {text: null},
                        min: 0,
                        labels: {
                            style: {color: "#005eb8"}
                        }
                    }]
                }
            }, overrides || {});
        }
    });

})();
Ext.define('Rally.technicalservices.HierarchyLoader',{
    logger: new Rally.technicalservices.Logger(),

    storyModelName: 'hierarchicalrequirement',
    taskModelName: 'task',
    testCaseModelName: 'testcase',
    defectModelName: 'defect',

    mixins: {
        observable: 'Ext.util.Observable'
    },

    model: undefined,
    filters: undefined,
    fetch: undefined,
    childModels: undefined,

    maxParallelCalls: 6,

    constructor: function (config) {
        this.mixins.observable.constructor.call(this, config);
        this.portfolioItemTypes = config.portfolioItemTypes || [];
        this.models = config.models || null;
        this.fetch = config.fetch || [];
        this.filters = config.filters || [];
        this.loadChildModels = config.loadChildModels || [];
        
        if (! Ext.isArray(this.models) ) { this.models = [this.models]; }
    },
    load: function(){

        if (!this.models || this.models.length === 0){
            this.fireEvent('hierarchyloaderror', "No models specified.");
            return;
        }
        if (this.portfolioItemTypes.length === 0){
            this.fireEvent('hierarchyloaderror', "Portfolio Item Types not initialized.");
            return;
        }
        if (!(this.loadChildModels instanceof Array)){
            this.fireEvent('hierarchyloaderror', "No child models specified.");
            return;
        }

        var fns = [];
        for (var i = 0; i< this.loadChildModels.length + 2; i++){
            fns.push(this.fetchNextLevel);
        }

        Deft.Chain.pipeline(fns, this).then({
            success: function(){
                this.fireEvent('hierarchyloadcomplete');
            },
            failure: function(msg){
                this.fireEvent('hierarchyloaderror', msg);
            },
            scope: this
        });
    },
    fetchNextLevel: function(args){
        this.logger.log('fetchNextLevel', args, args && args.length);

        var me = this;
        
        if (!args){
            return this.fetchRoot();
        }

        args = _.flatten(args);
        this.logger.log('fetchNextLevel flattened args', args, args.length);
        
        var parents_by_type = {};
        Ext.Array.each(args, function(parent){
            if ( Ext.isFunction(parent.get) ) {
                var type = parent.get('_type');
                if ( Ext.isEmpty(parents_by_type[type]) ) {
                    parents_by_type[type] = [];
                }
                
                parents_by_type[type].push(parent);
            }
        });
        
        if (Ext.Object.getKeys(parents_by_type).length >  0) {
            
            var promises = [];
            Ext.Object.each(parents_by_type, function(type,parents) {
                me.fireEvent('hierarchyloadartifactsloaded', type, args);
    
                var portfolioItemTypePaths = _.pluck(me.portfolioItemTypes, 'typePath'),
                    portfolioItemOrdinal = _.indexOf(portfolioItemTypePaths, type);
    
                me.logger.log(' -- ', portfolioItemOrdinal, type);
                
                if (portfolioItemOrdinal === 0 && Ext.Array.contains(me.loadChildModels, me.storyModelName)) {
                    promises.push( function() { return me.fetchUserStories(args); });
                }
                if (portfolioItemOrdinal > 0 && Ext.Array.contains(me.loadChildModels, portfolioItemTypePaths[portfolioItemOrdinal - 1])) {
                    promises.push( function() { return me.fetchPortfolioItems(portfolioItemTypePaths[portfolioItemOrdinal - 1], args); });
                }
                
                var child_promises = [];
                
                if (type === me.storyModelName && Ext.Array.contains(me.loadChildModels, me.taskModelName)){
                    child_promises.push(function() { return me.fetchTasks(args) } );
                }
                
                if (type === me.storyModelName && Ext.Array.contains(me.loadChildModels, me.defectModelName)){
                    child_promises.push(function() { return me.fetchChildDefects(args) });
                }
                
                if (type === me.storyModelName && Ext.Array.contains(me.loadChildModels, me.testCaseModelName)){
                    child_promises.push(function() { return me.fetchTestCases(args) } );
                }
                if ( child_promises.length > 0 ) {
                    promises.push( function() { return Deft.Chain.sequence(child_promises); });
                }
            });
            
            if ( promises.length === 0 ) { return Promise.resolve([]); }
            
            return Deft.Chain.sequence(promises);
        }
        return Promise.resolve([]);
    },

    fetchRoot: function(){
        console.log('fetchRoot', this.models);
        var me = this;
        
        var config = {
            filters: this.filters
        };
        
        var promises = [];
        Ext.Array.each(this.models, function(model) {
            var fetch = me.fetch.concat(me.getRequiredFetchFields(model));
            var model_config = Ext.clone(config);
            model_config.model = model;
            model_config.fetch = fetch;
            promises.push(function() { return me.fetchWsapiRecords(model_config); });
        });
        
        this.fireEvent('statusupdate', "Loading artifacts");
        
        return Deft.Chain.sequence(promises);
    },
    fetchPortfolioItems: function(type, parentRecords){

        var fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'Children', 'Count');

        return this.fetchChunks(type, fetch, chunks, "Parent.ObjectID", Ext.String.format("Please Wait... Loading Children for {0} Portfolio Items", parentRecords.length));
    },
    
    _getChunks: function(parentRecords, countField, countFieldAttribute){
        var chunks = [],
            childCount = 0,
            maxListSize = 25,
            childCountTarget = 200,
            idx = 0;

        chunks[idx] = [];
        _.each(parentRecords, function(r){
            if ( !Ext.isFunction(r.get) ) { return; }
            
            var count = r.get(countField);
            if (countFieldAttribute && count){
                count = count[countFieldAttribute];
            }
            if (count > 0){  //using story count because it is a more accurate gauge of the number of user stories for a feature than UserStories.Count is, evne though it may not match exactly.
                childCount += count;
                if (childCount > childCountTarget || chunks[idx].length >= maxListSize){
                    idx++;
                    chunks[idx] = [];
                    childCount = 0;
                }
                chunks[idx].push(r.get('ObjectID'));
            }
        });

        return chunks;
    },
    fetchUserStories: function(parentRecords){
        this.logger.log('fetchUserStories');
        
        var type = this.storyModelName,
            fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'LeafStoryCount'),
            featureParentName = this.portfolioItemTypes[0].name.replace(/\s/g, '') + ".ObjectID";

        return this.fetchChunks(type, fetch, chunks, featureParentName, Ext.String.format("Please Wait... Loading User Stories for {0} Portfolio Items", parentRecords.length));
    },
    fetchTasks: function(parentRecords){
        var type = this.taskModelName,
            fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'Tasks', 'Count');

        return this.fetchChunks(type, fetch, chunks, "WorkProduct.ObjectID", Ext.String.format("Please Wait... Loading Tasks for {0} User Stories", parentRecords.length));
    },
    fetchTestCases: function(parentRecords){
        var type = this.testCaseModelName,
            fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'TestCases', 'Count');

        return this.fetchChunks(type, fetch, chunks, "WorkProduct.ObjectID", Ext.String.format("Please Wait... Loading {0} for {1} User Stories", type, parentRecords.length));
    },
    fetchChildDefects: function(parentRecords){
        var type = this.defectModelName,
            fetch = this.fetch.concat(this.getRequiredFetchFields(type)),
            chunks = this._getChunks(parentRecords, 'Defects', 'Count');

        return this.fetchChunks(type, fetch, chunks, "Requirement.ObjectID", Ext.String.format("Please Wait... Loading {0} for {1} User Stories", type, parentRecords.length));
    },
    
    fetchChunks: function(type, fetch, chunks, chunkProperty, statusString){
        this.logger.log('fetchChunks',fetch,  chunkProperty, chunks);

        if (chunks && chunks.length > 0 && chunks[0].length===0){
            return Promise.resolve([]);
        }

        this.fireEvent('statusupdate', statusString);

        var promises = [];
        _.each(chunks, function(c){
            var filters = _.map(c, function(ids){ return {property: chunkProperty, value: ids }; }),
                config = {
                    model: type,
                    fetch: fetch,
                    filters: Rally.data.wsapi.Filter.or(filters)
                };
            promises.push(function(){ return this.fetchWsapiRecords(config); });
        });

        return this.throttle(promises, this.maxParallelCalls, this);
    },
    fetchWsapiRecords: function(config){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',{
                model: config.model,
                fetch: config.fetch,
                filters: config.filters,
                compact: false,
                limit: 'Infinity'
            }).load({
                callback: function(records, operation){
                    if (operation.wasSuccessful()){
                        var fids = _.map(records, function(r){
                            return r.get('FormattedID')
                        });
                        deferred.resolve(records);
                    } else {
                        deferred.reject('fetchWsapiRecords error: ' + operation.error.errors.join(','));
                    }
                },
                scope: this
        });
        return deferred;
    },
    getRequiredFetchFields: function(type){
        if (/^portfolioitem/.test(type.toLowerCase())){
            return ['Children', 'LeafStoryCount','Parent','ObjectID'];
        }

        if (type.toLowerCase() === this.storyModelName){
            return ['FormattedID','Children','Tasks','Parent','PortfolioItem','HasParent','ObjectID','TestCases','Defects'];
        }

        if (type.toLowerCase() === this.taskModelName){
            return ['WorkProduct','ObjectID'];
        }
        
        if (type.toLowerCase() === this.defectModelName){
            return ['Requirement','ObjectID'];
        }
        
        if (type.toLowerCase() === this.testCaseModelName){
            return ['WorkProduct','ObjectID'];
        }
        return [];
    },
    throttle: function (fns, maxParallelCalls, scope) {

        if (maxParallelCalls <= 0 || fns.length < maxParallelCalls){
            return Deft.promise.Chain.parallel(fns, scope);
        }


        var parallelFns = [],
            fnChunks = [],
            idx = -1;

        for (var i = 0; i < fns.length; i++) {
            if (i % maxParallelCalls === 0) {
                idx++;
                fnChunks[idx] = [];
            }
            fnChunks[idx].push(fns[i]);
        }

        _.each(fnChunks, function (chunk) {
            parallelFns.push(function () {
                return Deft.promise.Chain.parallel(chunk, scope);
            });
        });

        return Deft.Promise.reduce(parallelFns, function(groupResults, fnGroup) {
            return Deft.Promise.when(fnGroup.call(scope)).then(function(results) {
                groupResults = groupResults.concat(results || []);
                return groupResults;
            });
        }, []);
    }

});
Ext.define('Rally.technicalservices.HierarchyExporter',{

    logger: new Rally.technicalservices.Logger(),
    mixins: {
        observable: 'Ext.util.Observable'
    },

    records: undefined,

    constructor: function (config) {
        this.mixins.observable.constructor.call(this, config);
        this.records = [];
        this.fileName = config.fileName || "export.csv";
        this.columns = config.columns || [{dataIndex: 'FormattedID', text: 'ID'},{dataIndex: 'Name', text: 'Name'}];
        this.portfolioItemTypeObjects =  config.portfolioItemTypeObjects || [];

    },
    setRecords: function(type, records){
        this.records = (this.records || []).concat(records);
    },
    
    _cleanRecords: function(records) {
        return Ext.Array.filter(records, function(record){
            return Ext.isFunction(record.get);
        });
    },
    
    doExport: function(){

        this.fireEvent('exportupdate', "Preparing export data");

        this.logger.log('doExport', this.records, this);

        this.records = this._cleanRecords(this.records);
        
        var columns = _.filter(this.columns, function(c){ return c.dataIndex !== "FormattedID"; }),
            hierarchicalData = this._buildHierarchy(),
            exportData = this._getExportableHierarchicalData(hierarchicalData,columns);

        columns = this._getAncestorTypeColumns(hierarchicalData[0]._type).concat(columns);

        var csv = this._transformDataToDelimitedString(exportData, columns);

        this.saveCSVToFile(csv, this.fileName);
        this.fireEvent('exportcomplete');

    },
    _buildHierarchy: function(){
        var rootItems = [];
        this.logger.log('_buildHierarchy', this.records.length, this.records);

        var objectHash = _.reduce(this.records, function(objHash, record){
            var oid = record.get('ObjectID');
            objHash[oid] = record.getData();
            objHash[oid].loadedChildren = [];
            return objHash;
        }, {});

        this.logger.log('_buildhierarchy Hash', objectHash)

        this.records = null;

        for (var key in objectHash){
            var obj = objectHash[key],
                parent = obj.Parent && obj.Parent.ObjectID ||
                         obj.PortfolioItem && obj.PortfolioItem.ObjectID ||
                         obj.WorkProduct && obj.WorkProduct.ObjectID ||
                         obj.Requirement && obj.Requirement.ObjectID;

         //   if (obj._type === 'task') { console.log('obj',parent, obj._type, obj)};
            if (parent && objectHash[parent]){
                objectHash[parent].loadedChildren.push(obj);
            } else {
                var grandParent = obj.Parent && obj.Parent.Parent && obj.Parent.Parent.ObjectID || null;
                if (grandParent && objectHash[grandParent]){
                    objectHash[grandParent].loadedChildren.push(obj);
                } else {
                    rootItems.push(obj);
                }
            }
        }
        return rootItems;
    },
    _transformDataToDelimitedString: function(data, columns){
        var csvArray = [],
            delimiter = ",",
            rowDelimiter = "\r\n",
            re = new RegExp(delimiter + '|\"|\r|\n','g');

        var column_keys = _.map(columns, function(c){ return c.dataIndex; }),
            column_headers = _.pluck(columns, 'text');

        csvArray.push(column_headers.join(delimiter));

        Ext.Array.each(data, function(obj){
            var data = [];
            Ext.Array.each(column_keys, function(key){
                var val = obj[key];
                if (val){
                    if (re.test(val)){ //enclose in double quotes if we have the delimiters
                        val = val.replace(/\"/g,'\"\"');
                        val = Ext.String.format("\"{0}\"",val);
                    }
                }
                data.push(val);
            });
            csvArray.push(data.join(delimiter));
        });

        return csvArray.join(rowDelimiter);
    },
    /**
     * Returns an array of hash rollup data
     *
     * @param rootObjectIDs
     * @param columns - the data index of the columns that we want to export.
     * @param rollupData
     * @returns {Array}
     * @private
     */
    _getExportableHierarchicalData: function(hierarchyData, columns){

        var exportData = [];

        _.each(hierarchyData, function(r){
            var ancestors = {};
            var rec = this._getExportDataRow(r, columns, ancestors);
            exportData.push(rec);
            this._addExportChildren(r,exportData, columns, ancestors);
        }, this);

        return exportData;
    },
    _addExportChildren: function(record, exportData, columns, ancestors){
        var new_ancestors = Ext.clone(ancestors),
            me = this;

        new_ancestors[record._type] = record.FormattedID;

        var children = record.loadedChildren;
        if (children && children.length > 0){
            _.each(children, function(c){
                var row = this._getExportDataRow(c, columns, new_ancestors);
                exportData.push(row);
                me._addExportChildren(c, exportData, columns, new_ancestors);
            }, this);
        }
        return;
    },
    
    getTypePathDisplayName: function(modelName){
        
        var display_names = {
            'hierarchicalrequirement': 'User Story',
            'task': 'Task',
            'testcase': 'TestCase',
            'defect': 'Defect'
        };
        
        if ( !Ext.isEmpty(display_names[modelName.toLowerCase()]) ) {
            return display_names[modelName.toLowerCase()];
        }

        var displayName = '';
        Ext.Array.each(this.portfolioItemTypeObjects, function(p){
            if (p.typePath.toLowerCase() === modelName.toLowerCase()){
                displayName = p.name;
                return false;
            }
        });
        return displayName;
    },
    _getExportDataRow: function(recData, columns, ancestors){

        var rec = Ext.clone(ancestors),
            type = recData._type; //obj.getData('type');

        rec[type] = recData.FormattedID;
        rec.type = this.getTypePathDisplayName(recData._type);

        _.each(columns, function(c){
            var field = c.dataIndex || null;
            if (field){
                var data = recData[field];
                if (Ext.isObject(data)){
                    if (data._tagsNameArray && data._tagsNameArray.length > 0) {
                        var names = _.pluck(data._tagsNameArray, 'Name');
                        rec[field] = names.join(',');
                    } else {
                        rec[field] = data._refObjectName;
                    }
                } else if (Ext.isDate(data)){
                    rec[field] = Rally.util.DateTime.formatWithDefaultDateTime(data);
                } else {
                    rec[field] = data;
                }
            }
        });
        return rec;
    },
    _getAncestorTypeColumns: function(rootModel){
        var piTypes = this.portfolioItemTypeObjects,
            piIdx = -1;

        Ext.Array.each(piTypes, function(piObj, idx){
            if (piObj.typePath.toLowerCase() === rootModel.toLowerCase()){
                piIdx = idx;
            }
        });

        var columns = [{
            dataIndex: 'testcase',
            text: 'TestCase'
        },{
            dataIndex: 'defect',
            text: 'Defect'
        },{
            dataIndex: 'task',
            text: 'Task'
        },{
            dataIndex: 'hierarchicalrequirement',
            text: 'User Story'
        }];

        if (piIdx >= 0){
            columns = columns.concat(Ext.Array.map(piTypes.slice(0,piIdx+1), function(piObj) { return { dataIndex: piObj.typePath.toLowerCase(), text: piObj.name };} ));
            columns.push({
                dataIndex: 'type',
                text: 'Artifact Type'
            });

        }
        columns.reverse();
        return columns;
    },
    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },
    saveAs: function(textToWrite, fileName)
    {
        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder && e.name == 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    }
});
(function () {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Iteration Tracking Board App
     * The Iteration Tracking Board can be used to visualize and manage your User Stories and Defects within an Iteration.
     */
    Ext.define('technical-services-MilestoneTrackingApp', {
        extend: 'Rally.app.App',
        componentCls: 'iterationtrackingboard',
        logger: new Rally.technicalservices.Logger(),
        settingsScope: 'project',
        autoScroll: false,

        config: {
            defaultSettings: {
                ignoreProjectScoping: true,
                closedDefectStates: ['Closed'],
                cancelledDefectStates: [],
                includeFeatureUserStories: false
            }
        },
        items: [
            {xtype:'container',itemId:'selection_box', layout: {type: 'hbox'}, padding: 10},
            {xtype:'container',itemId:'banner_box'},
            {xtype:'container',itemId:'grid_box'}
        ],

        integrationHeaders : {
                name : "ts-MilestoneTrackingApp"
        },

        sModelNames: [],

        launch: function(){

            if(!this.rendered) {
                this.on('afterrender', this.launch, this, {single: true});
                return;
            }

            var promises = [
                Rally.technicalservices.Utilities.fetchScheduleStates(),
                Rally.technicalservices.Utilities.fetchPortfolioTypes()
            ];

            Deft.Promise.all(promises).then({
                scope: this,
                success: function(results){
                    this.logger.log('results',results);
                    this.sModelNames = Ext.Array.from(_.first(results[1]).get('TypePath'));
                    this.scheduleStates = results[0];
                    this._addComponents();
                },
                failure: function(msg){
                    Rally.ui.notify.Notifier.showError({message: msg});
                }
            });
        },
        _addComponents: function(){

            var filters = Ext.create('Rally.data.wsapi.Filter',{
                property: 'Projects',
                operator: 'contains',
                value: this.getContext().getProject()._ref
            });
            filters = filters.or({
                property: 'TargetProject',
                value: null
            });
            this.logger.log('filters', filters.toString());
            var cb = this.down('#selection_box').add({
                xtype: 'rallymilestonecombobox',
                stateful: true,
                stateId: this.getContext().getScopedStateId('milestone-cb'),
                storeConfig: {
                    filters: filters,
                    remoteFilter: true
                }
            });
            cb.on('change', this._update, this);

            var tpl = new Ext.XTemplate('<div class="selector-msg"><tpl if="days &gt;= 0">Target Date: {targetDate} ({days} days remaining)',
                '<tpl elseif="days &lt; 0">Target Date: {targetDate} <span style="color:red;">({days*(-1)} days past)</span>',
                '<tpl else><span style="color:red;">No target date set for milestone</span></tpl></div>');

            this.down('#selection_box').add({
                xtype: 'container',
                itemId: 'remaining-days',
                flex: 1,
                tpl: tpl
            });


            var lt_tpl = new Ext.XTemplate('<tpl if="latestories &gt; 0"><div class="picto icon-warning warning" style="color:#FAD200;font-size:16px;"></div>',
                '<div class="latestories">{latestories} Late Stories</div></tpl>')

            this.down('#selection_box').add({
                xtype: 'container',
                itemId: 'late-stories',
                flex: 1,
                style: {
                    textAlign: 'right',
                    cursor: 'pointer'
                },
                tpl: lt_tpl,
                listeners: {
                    scope: this,
                    afterrender: function(cmp){
                        cmp.getEl().on('click', this._showLateStoriesPopover, this);
                    }
                }
            });
        },

        _showLateStoriesPopover: function(event, target){
            this.logger.log('_showLateStoriesPopover',  target);

            if (this.lateStories && this.lateStories.length > 0){

                var html = _.map(this.lateStories, function(s){ return Ext.String.format('<li>{0}: {1} ({2})', s.get('FormattedID'), s.get('Name'), s.get('Iteration') && s.get('Iteration').Name || "Unscheduled")});
                html = Ext.String.format('<ul>{0}</ul>',html);

                html += "<br/><i>Late Stories are work items that are scheduled into an iteration that ends after the Milestone target date or items that are not scheduled into an iteration.</i>" ;

                var tt = Ext.create('Rally.ui.tooltip.ToolTip', {
                    target : target,
                    html: html,
                    destroyAfterHide: true
                });
                tt.show();
            }



        },
        _update: function(){

            this.down('#banner_box').removeAll();
            this.down('#grid_box').removeAll();

            var rec = this._getTimeBoxRecord();
            if (rec){
                var targetDate = Rally.util.DateTime.fromIsoString(rec.get('TargetDate')),
                    days = Rally.util.DateTime.getDifference(targetDate,new Date(), 'day'),
                    formattedTargetDate = Rally.util.DateTime.formatWithDefault(targetDate);
                this.down('#remaining-days').update({days: days, targetDate: formattedTargetDate});
            }

            this._addStatsBanner();
            this._getGridStore().then({
                success: this._addGridBoard,
                scope: this
            });

        },
        _getModelNames: function () {
            this.logger.log('_getModelNames',this.sModelNames);
            return this.sModelNames.concat(['HierarchicalRequirement','Defect']);
        },

        getSettingsFields: function () {
            var fields = this.callParent(arguments);
            fields.push({
                name: 'ignoreProjectScoping',
                xtype: 'rallycheckboxfield',
                labelWidth: 200,
                labelAlign: 'right',
                label: 'Show Children in any Project'
            });

            fields.push({
                name: 'closedDefectStates',
                xtype: 'rallyfieldvaluecombobox',
                width: 400,
                labelWidth: 200,
                labelAlign: 'right',
                multiSelect: true,
                fieldLabel: 'Inactive Defect States',
                emptyText : "Select Inactive States...",
                model: 'defect',
                field: 'State',
                listConfig : {
                    getInnerTpl : function() {
                        return '<div class="x-combo-list-item"><img src="" class="chkCombo-default-icon chkCombo" /> {displayName} </div>';
                    }
                }
            });

            fields.push({
                name: 'cancelledDefectStates',
                xtype: 'rallyfieldvaluecombobox',
                width: 400,
                labelWidth: 200,
                labelAlign: 'right',
                multiSelect: true,
                fieldLabel: 'Cancelled Defect States',
                emptyText : "Select Cancelled States...",
                model: 'defect',
                field: 'State',
                listConfig : {
                    getInnerTpl : function() {
                        return '<div class="x-combo-list-item"><img src="" class="chkCombo-default-icon chkCombo" /> {displayName} </div>';
                    }
                }
            });

            fields.push({
                xtype: 'rallycheckboxfield',
                fieldLabel: 'Include derived User Stories',
                labelWidth: 200,
                labelAlign: 'right',
                boxLabel: "<i>Include leaf User Stories on Milestone Portfolio Items that are not explicitly associated with the release.</i>",
                name: 'includeFeatureUserStories'
            });
            return fields;
        },
        _getFilters: function(){
            var filters = [];
            if (this._getTimeBoxRecord()){
                filters = Rally.data.wsapi.Filter({
                    property: "Milestones",
                    value: this._getMilestoneRef()
                });
            }

            return filters;
        },
        _getMilestoneRef: function(){
            var rec = this._getTimeBoxRecord();
            if (rec){
                return rec.get('_ref');
            }
            return null;
        },
        _getTimeBoxRecord: function(){
            if (this.down('rallymilestonecombobox') && this.down('rallymilestonecombobox').getRecord()){
                return this.down('rallymilestonecombobox').getRecord();
            }
            return null;
        },
        _getGridStore: function() {
            var context = this.getContext(),
                config = {
                    models: this._getModelNames(),
                    autoLoad: false,
                    remoteSort: true,
                    root: {expanded: true},
                    enableHierarchy: true,
                    context: {project: null}
                    //expandingNodesRespectProjectScoping: !this.getSetting('ignoreProjectScoping')
                };

            //config.filters = this._getFilters();
            return Ext.create('Rally.data.wsapi.TreeStoreBuilder').build(config).then({
                success: function (store) {
                    return store;
                },
                scope: this
            });
        },
        _updateLateStories: function(latestories){
            this.logger.log('_updateLateStories', latestories);
            this.down('#late-stories').update({latestories: latestories.length});
            this.lateStories = latestories;
        },
        getIncludeFeatureUserStories: function(){
            return (this.getSetting('includeFeatureUserStories') === 'true' || this.getSetting('includeFeatureUserStories') === true) || false;
        },
        getFeatureName: function(){
            return "Feature";
        },
        _addStatsBanner: function() {

            this.remove('statsBanner');
            this.down('#banner_box').add({
                xtype: 'statsbanner',
                itemId: 'statsBanner',
                //storeConfig: this._getStoreConfigs(),
                scheduleStates: this.scheduleStates,
                context: this.getContext(),
                timeboxRecord: this._getTimeBoxRecord(),
                timeboxEndDateField: 'TargetDate',
                filters: this._getFilters(),
                includeFeatureUserStories: this.getIncludeFeatureUserStories(),
                featureName: this.getFeatureName(),
                closedDefectStates: this.getSetting('closedDefectStates'),
                cancelledDefectStates: this.getSetting('cancelledDefectStates'),
                margin: '0 0 5px 0',
                listeners: {
                    resize: this._resizeGridBoardToFillSpace,
                    scope: this,
                    latestoriesfound: this._updateLateStories
                }
            });
        },

        _addGridBoard: function (gridStore) {
            var context = this.getContext();


            this.gridboard = this.down('#grid_box').add({
                itemId: 'gridBoard',
                xtype: 'rallygridboard',
                stateId: 'portfoliotracking-gridboard',
                context: context,
                plugins: this._getGridBoardPlugins(),
                modelNames: this._getModelNames(),
                gridConfig: this._getGridConfig(gridStore),
                storeConfig: {
                    filters: this._getFilters()
                },
                addNewPluginConfig: {
                    style: {
                        'float': 'left',
                        'margin-right': '5px'
                    }
                },
                listeners: {
                    load: this._onLoad,
                    afterrender : function() {
                        this.setWidth(this.getWidth()+1);
                    },
                    scope: this
                },
                height: Math.max(this.getAvailableGridBoardHeight()-50, 150)
            });
        },

        /**
         * @private
         */
        getAvailableGridBoardHeight: function() {
            var height = this.getHeight();
            if(this.down('#statsBanner').rendered) {
                height -= this.down('#statsBanner').getHeight();
            }
            return height;
        },

        _getGridBoardPlugins: function() {
            var plugins = ['rallygridboardaddnew'],
                context = this.getContext();

            var alwaysSelectedValues = ['FormattedID', 'Name', 'Owner'];
            if (context.getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled) {
                alwaysSelectedValues.push('DragAndDropRank');
            }

            plugins.push({
                ptype: 'rallygridboardfilterinfo',
                isGloballyScoped: Ext.isEmpty(this.getSetting('project')),
                stateId: 'iteration-tracking-owner-filter-' + this.getAppId()
            });

            plugins.push({
                ptype: 'rallygridboardfieldpicker',
                headerPosition: 'left',
                gridFieldBlackList: [
                    'ObjectID',
                    'Description',
                    'DisplayColor',
                    'Notes',
                    'Subscription',
                    'Workspace',
                    'Changesets',
                    'RevisionHistory',
                    'Children'
                ],
                boardFieldBlackList: [
                    'ObjectID',
                    'Description',
                    'DisplayColor',
                    'Notes',
                    'Rank',
                    'DragAndDropRank',
                    'Subscription',
                    'Workspace',
                    'Changesets',
                    'RevisionHistory',
                    'PortfolioItemType',
                    'StateChangedDate',
                    'Children'
                ],
                alwaysSelectedValues: alwaysSelectedValues,
                modelNames: this.modelNames,
                boardFieldDefaults: (this.getSetting('cardFields') && this.getSetting('cardFields').split(',')) ||
                ['Parent', 'Tasks', 'Defects', 'Discussion', 'PlanEstimate', 'Iteration']
            });

            plugins.push({
                ptype: 'rallygridboardcustomfiltercontrol',
                filterControlConfig: {
                    modelNames: this._getModelNames(),
                    stateful: true,
                    stateId: context.getScopedStateId('tracking-filters')
                },
                showOwnerFilter: true,
                ownerFilterControlConfig: {
                    stateful: true,
                    stateId: context.getScopedStateId('tracking-owner-filter')
                }
            });

            plugins.push({
                ptype: 'rallygridboardactionsmenu',
                menuItems: [
                    {
                        text: 'Export...',
                        handler: this._export,
                        scope: this,
                        childModels: ['hierarchicalrequirement','task','defect','testcase']
                    }
                ],
                buttonConfig: {
                    iconCls: 'icon-export'
                }
            });

            return plugins;
        },

        setHeight: Ext.Function.createBuffered(function() {
            this.superclass.setHeight.apply(this, arguments);
            this._resizeGridBoardToFillSpace();
        }, 100),

        _resizeGridBoardToFillSpace: function() {
            if(this.gridboard) {
                this.gridboard.setHeight(this.getAvailableGridBoardHeight());
            }
        },

        _getCustomViewConfig: function() {
            var customViewConfig = {
                ptype: 'rallygridboardcustomview',
                stateId: 'iteration-tracking-board-app',

                defaultGridViews: [{
                    model: ['UserStory', 'Defect', 'DefectSuite'],
                    name: 'Defect Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'Discussion',
                                'Priority',
                                'Severity',
                                'FoundIn',
                                'FixedIn',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                defectstatusview: {
                                    isActiveFilter: false,
                                    itemId: 'defectstatusview',
                                    queryString: '((Defects.ObjectID != null) OR (Priority != null))'
                                }
                            }
                        }
                    }
                }, {
                    model: ['UserStory', 'Defect', 'TestSet', 'DefectSuite'],
                    name: 'Task Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'PlanEstimate',
                                'TaskEstimate',
                                'ToDo',
                                'Discussions',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                taskstatusview: {
                                    isActiveFilter: false,
                                    itemId: 'taskstatusview',
                                    queryString: '(Tasks.ObjectID != null)'
                                }
                            }
                        }
                    }
                }, {
                    model: ['UserStory', 'Defect', 'TestSet'],
                    name: 'Test Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'Discussions',
                                'LastVerdict',
                                'LastBuild',
                                'LastRun',
                                'ActiveDefects',
                                'Priority',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                teststatusview: {
                                    isActiveFilter: false,
                                    itemId: 'teststatusview',
                                    queryString: '(TestCases.ObjectID != null)'
                                }
                            }
                        }
                    }
                }]
            };

            customViewConfig.defaultBoardViews = _.cloneDeep(customViewConfig.defaultGridViews);
            _.each(customViewConfig.defaultBoardViews, function(view) {
                delete view.state.cmpState;
            });

            return customViewConfig;
        },

        _createOwnerFilterItem: function (context) {
            var isPillPickerEnabled = context.isFeatureEnabled('BETA_TRACKING_EXPERIENCE'),
                projectRef = context.getProjectRef();

            if (isPillPickerEnabled) {
                return {
                    xtype: 'rallyownerpillfilter',
                    margin: '-15 0 5 0',
                    filterChildren: this.getContext().isFeatureEnabled('S58650_ALLOW_WSAPI_TRAVERSAL_FILTER_FOR_MULTIPLE_TYPES'),
                    project: projectRef,
                    showPills: false,
                    showClear: true
                };
            } else {
                return {
                    xtype: 'rallyownerfilter',
                    margin: '5 0 5 0',
                    filterChildren: this.getContext().isFeatureEnabled('S58650_ALLOW_WSAPI_TRAVERSAL_FILTER_FOR_MULTIPLE_TYPES'),
                    project: projectRef
                };
            }

        },

        _createTagFilterItem: function (context) {
            var filterUiImprovementsToggleEnabled = context.isFeatureEnabled('BETA_TRACKING_EXPERIENCE');
            return {
                xtype: 'rallytagpillfilter',
                margin: filterUiImprovementsToggleEnabled ? '-15 0 5 0' : '5 0 5 0',
                showPills: filterUiImprovementsToggleEnabled,
                showClear: filterUiImprovementsToggleEnabled,
                remoteFilter: filterUiImprovementsToggleEnabled
            };
        },

        _createModelFilterItem: function (context) {
            return {
                xtype: 'rallymodelfilter',
                models: this.modelNames,
                context: context
            };
        },

        _getGridConfig: function (gridStore) {
            var context = this.getContext(),
                stateString = 'release-tracking',
                stateId = context.getScopedStateId(stateString);

            var gridConfig = {
                store: gridStore,
                columnCfgs: ['Name'], //must set this to null to offset default behaviors in the gridboard
                defaultColumnCfgs: this._getGridColumns(),
                plugins: [],
                stateId: stateId,
                stateful: true
            };
            return gridConfig;
        },

        _getSummaryColumnConfig: function () {
            var taskUnitName = this.getContext().getWorkspace().WorkspaceConfiguration.TaskUnitName,
                planEstimateUnitName = this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName;

            return [
                {
                    field: 'AcceptedLeafStoryCount',
                    type: 'sum',
                    units: 'Total'
                },
                {
                    field: 'AcceptedLeafStoryPlanEstimateTotal',
                    type: 'sum',
                    units: planEstimateUnitName
                },
                {
                    field: 'LeafStoryCount',
                    type: 'sum',
                    units: 'Total'
                },
                {
                    field: 'LeafStoryPlanEstimateTotal',
                    type: 'sum',
                    units: planEstimateUnitName
                },
                {
                    field: 'UnEstimatedLeafStoryCount',
                    type: 'sum',
                    units: 'Total'
                }
            ];
        },

        _getGridColumns: function (columns) {
            var result = ['FormattedID', 'Name', 'PercentDoneByStoryPlanEstimate', 'PreliminaryEstimate', 'ScheduleState', 'PlanEstimate', 'Blocked', 'Iteration', 'Owner', 'Discussion'];

            if (columns) {
                result = columns;
            }
            _.pull(result, 'FormattedID');

            return result;
        },

        _onLoad: function (grid) {
            this.logger.log('_onLoad');
            var store = grid.getGridOrBoard().getStore(),
                re = new RegExp("portfolioitem/","i");

            store.each(function(record){
              if (re.test(record.get('_type')) && !record.get('UserStories') && record.get('DirectChildrenCount') > 0){
                 //todo: Fix this!!!!
                 this.logger.log('_onLoad Feature with missing children', record.get('FormattedID'), record);
              }
            },this);
        },

        _onBoardFilter: function () {
            this.setLoading(true);
        },

        _onBoardFilterComplete: function () {
            this.setLoading(false);
        },

        getOptions: function() {
            return [
                {
                    text: 'About...',
                    handler: this._launchInfo,
                    scope: this
                }
            ];
        },

        _getExportColumns: function(){
            var grid = this.down('rallygridboard').getGridOrBoard();
            if (grid){
                return _.filter(grid.columns, function(item){ return (item.dataIndex && item.dataIndex != "DragAndDropRank"); });
            }
            return [];
        },

        _getExportFilters: function(){
            var filters = this._getFilters();

            if ( ! Ext.isFunction(filters.and) ) {
                if ( Ext.isArray(filters) ) {
                    filters = Rally.data.wsapi.Filter.and(filters);
                } else {
                    filters = Ext.create('Rally.data.wsapi.Filter',filters);
                }
            }
            return filters;

//            var grid = this.down('rallygridboard'),
//                filters = [],
//                query = this.getSetting('query');
//
//            if (grid.currentCustomFilter && grid.currentCustomFilter.filters){
//                filters = grid.currentCustomFilter.filters;
//            }
//            if (query){
//                if (filters && filters.length > 0){
//                    return filters.and(filters, Rally.data.wsapi.Filter.fromQueryString(query));
//                } else {
//                    return Rally.data.wsapi.Filter.fromQueryString(query);
//                }
//            }
//            return filters;
        },

        _getExportFetch: function(){
            var fetch =  _.pluck(this._getExportColumns(), 'dataIndex');
            if (Ext.Array.contains(fetch, 'TaskActualTotal')){
                fetch.push('Actuals');
            }
            return fetch;
        },

        _showError: function(msg){
            Rally.ui.notify.Notifier.showError({message: msg});
        },
        _showStatus: function(message){
            this.logger.log('_showstatus', message, this);
            if (message) {
               Rally.ui.notify.Notifier.showStatus({
                    message: message,
                    showForever: true,
                    closable: false,
                    animateShowHide: false
                });
            } else {
                Rally.ui.notify.Notifier.hide();
            }
        },

        _export: function(args){

            var columns = this._getExportColumns(),
                fetch = this._getExportFetch(),
                filters = this._getExportFilters(),
                modelNames = this._getModelNames(),
                childModels = args.childModels;

            this.fetchPortfolioItemTypes().then({
                scope: this,
                success: function(pi_types) {
                    this.portfolioItemTypes = pi_types;

                    this.logger.log('_export', fetch, args, columns, childModels);
                    this.logger.log('_export Filters:', filters, filters.toString());

                    var exporter = Ext.create('Rally.technicalservices.HierarchyExporter', {
                        fileName: 'milestone-tracking-export.csv',
                        columns: columns,
                        portfolioItemTypeObjects: this.portfolioItemTypes

                    });
                    exporter.on('exportupdate', this._showStatus, this);
                    exporter.on('exporterror', this._showError, this);
                    exporter.on('exportcomplete', this._showStatus, this);

                    var hierarchyLoader = Ext.create('Rally.technicalservices.HierarchyLoader',{
                        models: modelNames,
                        fetch: fetch,
                        filters: filters,
                        loadChildModels: childModels,
                        portfolioItemTypes: this.portfolioItemTypes,
                        context: this.getContext().getDataContext()
                    });
                    hierarchyLoader.on('statusupdate', this._showStatus, this);
                    hierarchyLoader.on('hierarchyloadartifactsloaded', exporter.setRecords, exporter);
                    hierarchyLoader.on('hierarchyloadcomplete', exporter.doExport, exporter);
                    hierarchyLoader.on('hierarchyloaderror', this._showError, this);
                    hierarchyLoader.load();
                },
                failure: function(msg) {
                    Ext.Msg.alert('',msg);
                }
            });

        },

        _launchInfo: function() {
            if ( this.about_dialog ) { this.about_dialog.destroy(); }
            this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{
                informationHtml:  "<br/>"
            });
        },

        isExternal: function(){
            return typeof(this.getAppId()) == 'undefined';
        },
        onSettingsUpdate: function(settings){
            this.down('#selection_box').removeAll();
            this.down('#banner_box').removeAll();
            this.down('#grid_box').removeAll();
            this._addComponents();
        },

        fetchPortfolioItemTypes: function(){
            var deferred = Ext.create('Deft.Deferred');

            var store = Ext.create('Rally.data.wsapi.Store', {
                model: 'TypeDefinition',
                fetch: ['TypePath', 'Ordinal','Name'],
                filters: [
                    {
                        property: 'Parent.Name',
                        operator: '=',
                        value: 'Portfolio Item'
                    },
                    {
                        property: 'Creatable',
                        operator: '=',
                        value: 'true'
                    }
                ],
                sorters: [{
                    property: 'Ordinal',
                    direction: 'ASC'
                }]
            });
            store.load({
                callback: function(records, operation, success){

                    if (success){
                        var portfolioItemTypes = new Array(records.length);
                        _.each(records, function(d){
                            //Use ordinal to make sure the lowest level portfolio item type is the first in the array.
                            var idx = Number(d.get('Ordinal'));
                            portfolioItemTypes[idx] = { typePath: d.get('TypePath').toLowerCase(), name: d.get('Name') };
                            //portfolioItemTypes.reverse();
                        });
                        deferred.resolve(portfolioItemTypes);
                    } else {
                        var error_msg = '';
                        if (operation && operation.error && operation.error.errors){
                            error_msg = operation.error.errors.join(',');
                        }
                        deferred.reject('Error loading Portfolio Item Types:  ' + error_msg);
                    }
                }
            });
            return deferred.promise;
        }
    });
})();

            
               Rally.launchApp('technical-services-MilestoneTrackingApp', {
                   name: 'Milestone Tracking Board'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.icon-help {
    color: #c0c0c0;
    cursor: pointer;
}
a.tooltip {
    position: relative;
    text-decoration: none;
    color: #c0c0c0;
}

a.tooltip span{
    display: none;
}

a.tooltip:hover {
    position: absolute;
    top: -20px;
    left: 0px;
    display: block;
    width: 250px;
    color: white;
    background-color: black;
    border: 1px solid black;
    padding: 5px;
}

.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.selector-msg {
    color: #222222;
    font-family: ProximaNovaSemiBold,Helvetica,Arial;
    font-size: 14px;
    margin-top: 0px;
    margin-left: 15px;
    display: inline-block;
}
.latestories{
    color: #222222;
    font-family: ProximaNovaSemiBold,Helvetica,Arial;
    font-size: 14px;
    display: inline-block;
    margin-left: 5px;
    margin-right: 25px;
}
.iterationtrackingboard {
    overflow-y: hidden;
}
.iterationtrackingboard .header {
    line-height: normal;
    padding: 5px 5px 2px 5px;
}
.iterationtrackingboard .header .add-new {
    float: left;
}
.iterationtrackingboard .header .add-new .new {
    margin-left: 0;
}
.iterationtrackingboard .header .rui-triggerfield {
    margin-bottom: 5px;
}
.iterationtrackingboard .blank-slate-msg .x-panel-body {
    clear: both;
    padding-top: 20px;
    text-align: center;
}
.iterationtrackingboard .gridboard-filter-control {
    height: 22px;
    margin: 3px 0px 0px 5px;
}
.iterationtrackingboard .rui-leftright {
    margin-bottom: 10px;
}
.settings-no-grid {
    padding: 10px;
}
.icon-portfolioitem {
    speak: none;
    font-style: normal;
    font-weight: normal;
    font-variant: normal;
    text-transform: none;
    line-height: 1;
    -webkit-font-smoothing: antialiased;
}
.icon-portfolioitem:before {
    content: '\e024';
}
.stat-panel .collapsed-widget,
.stat-panel .collapsed-widget > div {
    display: none;
}
.stat-panel .expanded-widget,
.stat-panel .expanded-widget > div {
    display: block;
}
.stat-panel.collapsed .collapsed-widget,
.stat-panel.collapsed .collapsed-widget > div {
    display: inline-block;
}
.stat-panel.collapsed .expanded-widget,
.stat-panel.collapsed .expanded-widget > div {
    display: none;
}
.stats-banner .stat-panel {
    border-top: 1px solid #d6d6d6;
    border-left: 1px solid #d6d6d6;
    border-bottom: 1px solid #d6d6d6;
    height: 110px;
    text-align: center;
}
.stats-banner .stat-panel:first-child {
    border-left: 0;
}
.stats-banner .stat-panel:last-child {
    border-left-width: 2px;
}
.stats-banner .stat-panel .stat-title {
    color: #222222;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 12px;
    padding-top: 5px;
}
.stats-banner .stat-panel .stat-metric {
    color: #666666;
    font-family: ProximaNovaLight, Helvetica, Arial;
    font-size: 16px;
    height: 85px;
    padding-top: 20px;
}
.stats-banner .stat-panel .stat-metric .metric-percent {
    display: inline;
    font-size: 12px;
    vertical-align: super;
}
.stats-banner .stat-panel .stat-metric .metric-icon {
    color: #888888;
    font-size: 18px;
    padding-right: 5px;
}
.stats-banner .stat-panel .stat-metric .metric-chart {
    position: absolute;
    top: 22px;
    width: 100%;
    height: 75px;
}
.stats-banner .stat-panel .stat-metric .metric-subtext {
    bottom: 0px;
    color: #888888;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 11px;
    position: absolute;
    text-transform: lowercase;
    width: 100%;
    height: 20px;
}
.stats-banner .stat-panel .stat-metric .metric-chart-text {
    position: absolute;
    top: 43px;
    width: 100%;
}
.stats-banner .stat-panel .stat-metric .metric-chart-text.percent-offset {
    left: 10px;
    top: 41px;
}
.stats-banner .stat-panel .stat-metric .stat-secondary {
    color: #888888;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 11px;
    text-transform: lowercase;
}
.stats-banner .stat-panel .stat-metric .stat-carousel {
    display: inline-block;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 12px;
    margin-top: -20px;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .rally-carousel-pane .x-box-inner {
    top: 0px !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel > span {
    display: inline !important;
    width: auto !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel > span > div {
    display: block !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel .carousel-panel > span {
    display: inline !important;
    width: auto !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel .carousel-panel > span > div {
    display: block !important;
}
.stats-banner .stat-panel .chart .highcharts-container {
    cursor: pointer;
}
.stats-banner .stat-panel .gauge .chart .highcharts-container {
    height: 75px;
    cursor: default;
}
.stats-banner .stat-panel .header {
    display: none;
}
.stats-banner .stat-panel.collapse-expand {
    background-color: #f6f6f6;
    width: 23px;
}
.stats-banner .stat-panel.collapse-expand .toggle-icon {
    color: #c0c0c0;
    font-size: 18px;
    position: relative;
    right: 1px;
}
.stats-banner .stat-panel.collapse-expand:hover {
    cursor: pointer;
}
.stats-banner .stat-panel.collapse-expand:hover .toggle-icon {
    color: #888888;
}
.stats-banner.collapsed .stat-panel {
    height: 25px;
    padding-top: 2px;
}
.stats-banner.collapsed .stat-panel .metric-icon {
    color: #888888;
    font-size: 14px;
    padding-right: 5px;
    vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-title {
    color: #222222;
    display: inline;
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-size: 12px;
    vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-metric {
    color: #888888;
    display: inline;
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 14px;
    height: auto;
    padding-top: auto;
    padding-left: 10px;
    vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-metric .stat-metric-secondary {
    font-size: 11px;
}
.stats-banner.collapsed .stat-panel .stat-metric .metric-percent {
    font-size: 10px;
    vertical-align: super;
}
.pie-chart-legend {
    color: #3E576F;
    font-size: 12px;
    padding: 5px;
    border: 1px solid #909090;
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    border-radius: 5px;
}
.pie-chart-legend .legend-swatch {
    width: 17px;
    height: 12px;
    border: 1px solid #EEE;
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    border-radius: 5px;
    float: left;
    margin: 0 3px 0 6px;
}
.pie-chart-legend .legend-swatch.defined-sample-swatch {
    background: #E0E0E0;
    /* light-gray */
}
.pie-chart-legend .legend-swatch.in-progress-sample-swatch {
    background: #00a9e0;
}
.pie-chart-legend .legend-swatch.completed-sample-swatch {
    background: #8dc63f;
}
.pie-chart-legend .legend-swatch.blocked-sample-swatch {
    background: #EF3F35;
    /* rally red */
}
.iteration-progress-dialog .carousel .carousel-panel .scroll-button span {
    width: 45px;
    height: 50px;
    line-height: 46px;
}
.iteration-progress-dialog .carousel .carousel-panel .scroll-button span:hover {
    background-color: #e6e6e6;
    color: #666666;
}
.iteration-progress-toggle-button-group {
    margin-bottom: 5px;
}
.x-gecko .stats-banner.collapsed .stat-panel .stat-metric {
    line-height: 20px;
    vertical-align: top;
}
.x-gecko .stats-banner.collapsed .stat-panel .stat-metric .metric-percent {
    line-height: 10px;
}
.x-gecko.x-mac .stats-banner.collapsed .stat-panel .stat-metric {
    line-height: 22px;
}
    </style>

</head>
<body></body>
</html>